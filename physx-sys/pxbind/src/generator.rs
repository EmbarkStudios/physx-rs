#[macro_export]
macro_rules! writes {
    ($s:expr, $f:expr $(,)?) => {{
        use std::fmt::Write;
        write!($s, $f).unwrap();
    }};
    ($s:expr, $f:expr, $($arg:tt)*) => {{
        use std::fmt::Write;
        write!($s, $f, $($arg)*).unwrap();
    }};
}

#[macro_export]
macro_rules! writesln {
    ($s:expr) => {{
        use std::fmt::Write;
        writeln!($s).unwrap();
    }};
    ($s:expr, $f:expr $(,)?) => {{
        use std::fmt::Write;
        writeln!($s, $f).unwrap();
    }};
    ($s:expr, $f:expr, $($arg:tt)*) => {{
        use std::fmt::Write;
        writeln!($s, $f, $($arg)*).unwrap();
    }};
}

mod comment;
mod enums;
mod record;

use crate::consumer::{AstConsumer, EnumBinding, RecBinding};
use std::{fmt, io::Write};

/// The variable name of `PodStructGen` in the structgen program
const SG: &str = "sg";
/// The name of the macro used to calculate a field's offset in the structgen program
const UOF: &str = "unsafe_offsetof";

/// It's impossible (I believe) with Rust's format strings to have the width
/// of the alignment be dynamic, so we just uhhh...be lame
struct Indent(u32);

impl fmt::Display for Indent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for _ in 0..self.0 {
            f.write_str("    ")?;
        }

        Ok(())
    }
}

pub struct Generator {
    pub record_filter: Box<dyn Fn(&RecBinding<'_>) -> bool>,
    pub enum_filter: Box<dyn Fn(&EnumBinding<'_>) -> bool>,
}

impl Default for Generator {
    fn default() -> Self {
        Self {
            record_filter: Box::new(|_rb| true),
            enum_filter: Box::new(|_eb| true),
        }
    }
}

impl Generator {
    pub fn generate_all(
        &self,
        ast: &AstConsumer<'_>,
        structgen: &mut impl Write,
        cpp: &mut impl Write,
        rust: &mut impl Write,
    ) -> anyhow::Result<()> {
        self.generate_structgen(ast, structgen)?;
        self.generate_cpp(ast, cpp)?;
        self.generate_rust(ast, rust)?;

        Ok(())
    }

    /// Generates the structgen `main` function, which is used to generate
    /// the the POD types for C and Rust and guarantee their fields are
    /// appropriately sized and aligned so they can be interchanged
    pub fn generate_structgen(
        &self,
        ast: &AstConsumer<'_>,
        out: &mut impl Write,
    ) -> anyhow::Result<()> {
        // Preamble
        {
            // Get access to all of the PhysX types we're retrieving the layout for
            writeln!(out, "// Automatically generated by pxbind")?;
            writeln!(out, r#"#include "PxPhysicsAPI.h""#)?;
            writeln!(out, "\nusing namespace physx;")?;

            // Macro used to get the offset of each public field that the PODs
            // expose
            writeln!(
                out,
                "\n#define {UOF}(st, m) ((size_t) ( (char *)&((st *)(0))->m - (char *)0 ))"
            )?;
            // The header that contains the implementation of PodStructGen
            writeln!(out, r#"#include "structgen.hpp""#)?;
            writeln!(out, "\nint main() {{")?;
        }

        let indent = Indent(1);
        writeln!(out, "{indent}PodStructGen {SG};")?;

        let mut acc = String::new();
        for rec in ast.recs.iter().filter(|rb| (self.record_filter)(rb)) {
            acc.clear();
            rec.emit_structgen(&mut acc, 1);
            writeln!(out, "{acc}")?;
        }

        writeln!(out, "{indent}{SG}.finish();\n}}")?;

        Ok(())
    }

    pub fn generate_cpp(&self, ast: &AstConsumer<'_>, out: &mut impl Write) -> anyhow::Result<()> {
        self.generate_size_asserts(ast, out)?;

        let level = 0;
        let indent = Indent(level);
        writeln!(out, "{indent}extern \"C\" {{")?;
        self.generate_cpp_functions(ast, out, level + 1)?;
        writeln!(out, "{indent}}}")?;
        Ok(())
    }

    /// Generates the static assert code used to verify that every structgen
    /// POD type is the same size as the C++ type it is wrapping
    pub fn generate_size_asserts(
        &self,
        ast: &AstConsumer<'_>,
        out: &mut impl Write,
    ) -> anyhow::Result<()> {
        writeln!(
            out,
            "using namespace physx;\n#include \"structgen_out.hpp\"\n"
        )?;

        for rec in ast.recs.iter().filter(|rb| (self.record_filter)(rb)) {
            let name = rec.name;
            writeln!(out, "static_assert(sizeof(physx::{name}) == sizeof(physx_{name}_Pod), \"POD wrapper for `physx::{name}` has incorrect size")?;
        }

        writeln!(out)?;

        Ok(())
    }

    /// Generates the C functions used to convert between the C bridge types
    /// and calls into the C++ code
    pub fn generate_cpp_functions(
        &self,
        ast: &AstConsumer<'_>,
        out: &mut impl Write,
        level: u32,
    ) -> anyhow::Result<()> {
        Ok(())
    }

    pub fn generate_rust(&self, ast: &AstConsumer<'_>, w: &mut impl Write) -> anyhow::Result<()> {
        let level = 0;

        self.generate_rust_enums(ast, w, level)?;
        self.generate_rust_records(ast, w)?;

        let indent = Indent(level);
        writeln!(w, "{indent}extern \"C\" {{")?;
        self.generate_rust_functions(ast, w, level + 1)?;
        writeln!(w, "{indent}}}")?;

        Ok(())
    }

    pub fn generate_rust_enums(
        &self,
        ast: &AstConsumer<'_>,
        writer: &mut impl Write,
        level: u32,
    ) -> anyhow::Result<u32> {
        let mut fiter = ast.flags.iter().peekable();
        let mut acc = String::new();

        for (enum_binding, flags_binding) in ast.enums.iter().enumerate().filter_map(|(i, eb)| {
            let fb = if fiter.peek().map_or(false, |f| f.enums_index == i) {
                fiter.next()
            } else {
                None
            };

            if (self.enum_filter)(eb) {
                Some((eb, fb))
            } else {
                None
            }
        }) {
            if !acc.is_empty() {
                acc.clear();
                writesln!(acc);
            }

            enum_binding.emit_rust(&mut acc, level);

            if let Some(flags) = flags_binding {
                writesln!(acc);
                flags.emit_rust(enum_binding, &mut acc, level);
            }

            write!(writer, "{acc}")?;
        }

        Ok((ast.enums.len() + ast.flags.len()) as u32)
    }

    pub fn generate_rust_records(
        &self,
        ast: &AstConsumer<'_>,
        writer: &mut impl Write,
    ) -> anyhow::Result<u32> {
        let mut num = 0;
        let mut acc = String::new();

        for rec in ast.recs.iter().filter(|rb| (self.record_filter)(rb)) {
            acc.clear();
            writesln!(acc);

            if rec.emit_rust(&mut acc, 0) {
                num += 1;
            }

            write!(writer, "{acc}")?;
        }

        Ok(num)
    }

    pub fn generate_rust_functions(
        &self,
        ast: &AstConsumer<'_>,
        writer: &mut impl Write,
        level: u32,
    ) -> anyhow::Result<u32> {
        Ok(0)
    }
}
