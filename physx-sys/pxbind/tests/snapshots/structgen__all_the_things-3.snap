---
source: physx-sys/pxbind/tests/structgen.rs
expression: generated.rust
---
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxQuat {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMat33 {
    pub column0: glam::Vec3,
    pub column1: glam::Vec3,
    pub column2: glam::Vec3,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMat44 {
    pub column0: glam::Vec4,
    pub column1: glam::Vec4,
    pub column2: glam::Vec4,
    pub column3: glam::Vec4,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTransform {
    pub q: glam::Quat,
    pub p: glam::Vec3,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxAllocator {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRawAllocator {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVirtualAllocator {
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxUserAllocated {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTempAllocator {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVec3Padded {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub padding: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTransformPadded {
    pub transform: PxTransform,
    pub padding: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBounds3 {
    pub minimum: PxVec3,
    pub maximum: PxVec3,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxFPUGuard {
    pub structgen_pad0: [u8; 32],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSIMDGuard {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxPlane {
    pub n: PxVec3,
    pub d: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMutexImpl {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxReadWriteLock {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxProfileScoped {
    pub mCallback: *mut PxProfilerCallback,
    pub mEventName: *const std::ffi::c_char,
    pub mProfilerData: *mut std::ffi::c_void,
    pub mContextId: u64,
    pub mDetached: bool,
    pub structgen_pad0: [u8; 7],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSListEntry {
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSListImpl {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSocket {
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSyncImpl {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxThreadImpl {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCounterFrequencyToTensOfNanos {
    pub mNumerator: u64,
    pub mDenominator: u64,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTime {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxStridedData {
    pub stride: u32,
    pub structgen_pad0: [u8; 4],
    pub data: *const std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBoundedData {
    pub stride: u32,
    pub structgen_pad0: [u8; 4],
    pub data: *const std::ffi::c_void,
    pub count: u32,
    pub structgen_pad1: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDebugPoint {
    pub pos: PxVec3,
    pub color: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDebugLine {
    pub pos0: PxVec3,
    pub color0: u32,
    pub pos1: PxVec3,
    pub color1: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDebugTriangle {
    pub pos0: PxVec3,
    pub color0: u32,
    pub pos1: PxVec3,
    pub color1: u32,
    pub pos2: PxVec3,
    pub color2: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDebugText {
    pub position: PxVec3,
    pub size: f32,
    pub color: u32,
    pub structgen_pad0: [u8; 4],
    pub string: *const std::ffi::c_char,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTolerancesScale {
    pub length: f32,
    pub speed: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMetaDataEntry {
    pub type: *const std::ffi::c_char,
    pub name: *const std::ffi::c_char,
    pub offset: u32,
    pub size: u32,
    pub count: u32,
    pub offsetSize: u32,
    pub flags: u32,
    pub alignment: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBoxGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub halfExtents: PxVec3,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCapsuleGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub radius: f32,
    pub halfHeight: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxHullPolygon {
    pub mPlane: [f32; 4],
    pub mNbVerts: u16,
    pub mIndexBase: u16,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMeshScale {
    pub scale: PxVec3,
    pub rotation: PxQuat,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConvexMeshGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub scale: PxMeshScale,
    pub structgen_pad1: [u8; 4],
    pub convexMesh: *mut PxConvexMesh,
    pub meshFlags: PxConvexMeshGeometryFlags,
    pub structgen_pad2: [u8; 7],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSphereGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub radius: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxPlaneGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTriangleMeshGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub scale: PxMeshScale,
    pub meshFlags: PxMeshGeometryFlags,
    pub structgen_pad1: [u8; 3],
    pub triangleMesh: *mut PxTriangleMesh,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxHeightFieldGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub heightField: *mut PxHeightField,
    pub heightScale: f32,
    pub rowScale: f32,
    pub columnScale: f32,
    pub heightFieldFlags: PxMeshGeometryFlags,
    pub structgen_pad1: [u8; 3],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleSystemGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub mSolverType: PxParticleSolverType,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxHairSystemGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTetrahedronMeshGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub tetrahedronMesh: *mut PxTetrahedronMesh,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxQueryHit {
    pub faceIndex: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxLocationHit {
    pub faceIndex: u32,
    pub flags: PxHitFlags,
    pub structgen_pad0: [u8; 2],
    pub position: PxVec3,
    pub normal: PxVec3,
    pub distance: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGeomRaycastHit {
    pub faceIndex: u32,
    pub flags: PxHitFlags,
    pub structgen_pad0: [u8; 2],
    pub position: PxVec3,
    pub normal: PxVec3,
    pub distance: f32,
    pub u: f32,
    pub v: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGeomOverlapHit {
    pub faceIndex: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGeomSweepHit {
    pub faceIndex: u32,
    pub flags: PxHitFlags,
    pub structgen_pad0: [u8; 2],
    pub position: PxVec3,
    pub normal: PxVec3,
    pub distance: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGeomIndexPair {
    pub id0: u32,
    pub id1: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxQueryThreadContext {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCustomGeometry {
    pub structgen_pad0: [u8; 4],
    pub mTypePadding: f32,
    pub callbacks: *mut PxCustomGeometry::Callbacks,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGeometryHolder {
    pub structgen_pad0: [u8; 56],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGeometryQuery {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxHeightFieldSample {
    pub height: i16,
    pub materialIndex0: PxBitAndByte,
    pub materialIndex1: PxBitAndByte,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxHeightFieldDesc {
    pub nbRows: u32,
    pub nbColumns: u32,
    pub format: PxHeightFieldFormat,
    pub structgen_pad0: [u8; 4],
    pub samples: PxStridedData,
    pub convexEdgeThreshold: f32,
    pub flags: PxHeightFieldFlags,
    pub structgen_pad1: [u8; 2],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMeshQuery {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSimpleTriangleMesh {
    pub points: PxBoundedData,
    pub triangles: PxBoundedData,
    pub flags: PxMeshFlags,
    pub structgen_pad0: [u8; 6],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTriangle {
    pub verts: [PxVec3; 3],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTrianglePadded {
    pub verts: [PxVec3; 3],
    pub padding: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTetrahedron {
    pub verts: [PxVec3; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCollisionMeshMappingData {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSoftBodyCollisionData {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTetrahedronMeshData {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSoftBodySimulationData {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCollisionTetrahedronMeshData {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSimulationTetrahedronMeshData {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxActor {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxAggregate {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSpringModifiers {
    pub stiffness: f32,
    pub damping: f32,
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRestitutionModifiers {
    pub restitution: f32,
    pub velocityThreshold: f32,
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Px1DConstraint {
    pub linear0: PxVec3,
    pub geometricError: f32,
    pub angular0: PxVec3,
    pub velocityTarget: f32,
    pub linear1: PxVec3,
    pub minImpulse: f32,
    pub angular1: PxVec3,
    pub maxImpulse: f32,
    pub mods: Px1DConstraintMods,
    pub forInternalUse: f32,
    pub flags: u16,
    pub solveHint: u16,
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConstraintInvMassScale {
    pub linear0: f32,
    pub angular0: f32,
    pub linear1: f32,
    pub angular1: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPoint {
    pub normal: PxVec3,
    pub separation: f32,
    pub point: PxVec3,
    pub maxImpulse: f32,
    pub targetVel: PxVec3,
    pub staticFriction: f32,
    pub materialFlags: u8,
    pub structgen_pad0: [u8; 3],
    pub internalFaceIndex1: u32,
    pub dynamicFriction: f32,
    pub restitution: f32,
    pub damping: f32,
    pub structgen_pad1: [u8; 12],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSolverBody {
    pub linearVelocity: PxVec3,
    pub maxSolverNormalProgress: u16,
    pub maxSolverFrictionProgress: u16,
    pub angularState: PxVec3,
    pub solverProgress: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSolverBodyData {
    pub linearVelocity: PxVec3,
    pub invMass: f32,
    pub angularVelocity: PxVec3,
    pub reportThreshold: f32,
    pub sqrtInvInertia: PxMat33,
    pub penBiasClamp: f32,
    pub nodeIndex: u32,
    pub maxContactImpulse: f32,
    pub body2World: PxTransform,
    pub pad: u16,
    pub structgen_pad0: [u8; 2],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConstraintBatchHeader {
    pub startIndex: u32,
    pub stride: u16,
    pub constraintType: u16,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSolverConstraintDesc {
    pub structgen_pad0: [u8; 16],
    pub bodyADataIndex: u32,
    pub bodyBDataIndex: u32,
    pub linkIndexA: u32,
    pub linkIndexB: u32,
    pub constraint: *mut u8,
    pub writeBack: *mut std::ffi::c_void,
    pub progressA: u16,
    pub progressB: u16,
    pub constraintLengthOver16: u16,
    pub padding: [u8; 10],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSolverConstraintPrepDescBase {
    pub invMassScales: PxConstraintInvMassScale,
    pub desc: *mut PxSolverConstraintDesc,
    pub body0: *const PxSolverBody,
    pub body1: *const PxSolverBody,
    pub data0: *const PxSolverBodyData,
    pub data1: *const PxSolverBodyData,
    pub bodyFrame0: PxTransform,
    pub bodyFrame1: PxTransform,
    pub bodyState0: BodyState,
    pub bodyState1: BodyState,
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSolverConstraintPrepDesc {
    pub invMassScales: PxConstraintInvMassScale,
    pub desc: *mut PxSolverConstraintDesc,
    pub body0: *const PxSolverBody,
    pub body1: *const PxSolverBody,
    pub data0: *const PxSolverBodyData,
    pub data1: *const PxSolverBodyData,
    pub bodyFrame0: PxTransform,
    pub bodyFrame1: PxTransform,
    pub bodyState0: BodyState,
    pub bodyState1: BodyState,
    pub structgen_pad0: [u8; 8],
    pub rows: *mut Px1DConstraint,
    pub numRows: u32,
    pub linBreakForce: f32,
    pub angBreakForce: f32,
    pub minResponseThreshold: f32,
    pub writeback: *mut std::ffi::c_void,
    pub disablePreprocessing: bool,
    pub improvedSlerp: bool,
    pub driveLimitsAreForces: bool,
    pub extendedLimits: bool,
    pub disableConstraint: bool,
    pub structgen_pad1: [u8; 3],
    pub body0WorldOffset: PxVec3Padded,
    pub structgen_pad2: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSolverContactDesc {
    pub invMassScales: PxConstraintInvMassScale,
    pub desc: *mut PxSolverConstraintDesc,
    pub body0: *const PxSolverBody,
    pub body1: *const PxSolverBody,
    pub data0: *const PxSolverBodyData,
    pub data1: *const PxSolverBodyData,
    pub bodyFrame0: PxTransform,
    pub bodyFrame1: PxTransform,
    pub bodyState0: BodyState,
    pub bodyState1: BodyState,
    pub shapeInteraction: *mut std::ffi::c_void,
    pub contacts: *mut PxContactPoint,
    pub numContacts: u32,
    pub hasMaxImpulse: bool,
    pub disableStrongFriction: bool,
    pub hasForceThresholds: bool,
    pub structgen_pad0: [u8; 1],
    pub restDistance: f32,
    pub maxCCDSeparation: f32,
    pub frictionPtr: *mut u8,
    pub frictionCount: u8,
    pub structgen_pad1: [u8; 7],
    pub contactForces: *mut f32,
    pub startFrictionPatchIndex: u32,
    pub numFrictionPatches: u32,
    pub startContactPatchIndex: u32,
    pub numContactPatches: u16,
    pub axisConstraintCount: u16,
    pub offsetSlop: f32,
    pub structgen_pad2: [u8; 12],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationLimit {
    pub low: f32,
    pub high: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationDrive {
    pub stiffness: f32,
    pub damping: f32,
    pub maxForce: f32,
    pub driveType: PxArticulationDriveType,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTGSSolverBodyVel {
    pub linearVelocity: PxVec3,
    pub nbStaticInteractions: u16,
    pub maxDynamicPartition: u16,
    pub angularVelocity: PxVec3,
    pub partitionMask: u32,
    pub deltaAngDt: PxVec3,
    pub maxAngVel: f32,
    pub deltaLinDt: PxVec3,
    pub lockFlags: u16,
    pub isKinematic: bool,
    pub pad: u8,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTGSSolverBodyTxInertia {
    pub deltaBody2World: PxTransform,
    pub sqrtInvInertia: PxMat33,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTGSSolverBodyData {
    pub originalLinearVelocity: PxVec3,
    pub maxContactImpulse: f32,
    pub originalAngularVelocity: PxVec3,
    pub penBiasClamp: f32,
    pub invMass: f32,
    pub nodeIndex: u32,
    pub reportThreshold: f32,
    pub pad: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTGSSolverConstraintPrepDescBase {
    pub invMassScales: PxConstraintInvMassScale,
    pub desc: *mut PxSolverConstraintDesc,
    pub body0: *const PxTGSSolverBodyVel,
    pub body1: *const PxTGSSolverBodyVel,
    pub body0TxI: *const PxTGSSolverBodyTxInertia,
    pub body1TxI: *const PxTGSSolverBodyTxInertia,
    pub bodyData0: *const PxTGSSolverBodyData,
    pub bodyData1: *const PxTGSSolverBodyData,
    pub bodyFrame0: PxTransform,
    pub bodyFrame1: PxTransform,
    pub bodyState0: BodyState,
    pub bodyState1: BodyState,
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTGSSolverConstraintPrepDesc {
    pub invMassScales: PxConstraintInvMassScale,
    pub desc: *mut PxSolverConstraintDesc,
    pub body0: *const PxTGSSolverBodyVel,
    pub body1: *const PxTGSSolverBodyVel,
    pub body0TxI: *const PxTGSSolverBodyTxInertia,
    pub body1TxI: *const PxTGSSolverBodyTxInertia,
    pub bodyData0: *const PxTGSSolverBodyData,
    pub bodyData1: *const PxTGSSolverBodyData,
    pub bodyFrame0: PxTransform,
    pub bodyFrame1: PxTransform,
    pub bodyState0: BodyState,
    pub bodyState1: BodyState,
    pub rows: *mut Px1DConstraint,
    pub numRows: u32,
    pub linBreakForce: f32,
    pub angBreakForce: f32,
    pub minResponseThreshold: f32,
    pub writeback: *mut std::ffi::c_void,
    pub disablePreprocessing: bool,
    pub improvedSlerp: bool,
    pub driveLimitsAreForces: bool,
    pub extendedLimits: bool,
    pub disableConstraint: bool,
    pub structgen_pad0: [u8; 3],
    pub body0WorldOffset: PxVec3Padded,
    pub cA2w: PxVec3Padded,
    pub cB2w: PxVec3Padded,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTGSSolverContactDesc {
    pub invMassScales: PxConstraintInvMassScale,
    pub desc: *mut PxSolverConstraintDesc,
    pub body0: *const PxTGSSolverBodyVel,
    pub body1: *const PxTGSSolverBodyVel,
    pub body0TxI: *const PxTGSSolverBodyTxInertia,
    pub body1TxI: *const PxTGSSolverBodyTxInertia,
    pub bodyData0: *const PxTGSSolverBodyData,
    pub bodyData1: *const PxTGSSolverBodyData,
    pub bodyFrame0: PxTransform,
    pub bodyFrame1: PxTransform,
    pub bodyState0: BodyState,
    pub bodyState1: BodyState,
    pub shapeInteraction: *mut std::ffi::c_void,
    pub contacts: *mut PxContactPoint,
    pub numContacts: u32,
    pub hasMaxImpulse: bool,
    pub disableStrongFriction: bool,
    pub hasForceThresholds: bool,
    pub structgen_pad0: [u8; 1],
    pub restDistance: f32,
    pub maxCCDSeparation: f32,
    pub frictionPtr: *mut u8,
    pub frictionCount: u8,
    pub structgen_pad1: [u8; 7],
    pub contactForces: *mut f32,
    pub startFrictionPatchIndex: u32,
    pub numFrictionPatches: u32,
    pub startContactPatchIndex: u32,
    pub numContactPatches: u16,
    pub axisConstraintCount: u16,
    pub maxImpulse: f32,
    pub torsionalPatchRadius: f32,
    pub minTorsionalPatchRadius: f32,
    pub offsetSlop: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationTendonLimit {
    pub lowLimit: f32,
    pub highLimit: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationAttachment {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationTendonJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationTendon {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationSpatialTendon {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationFixedTendon {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSpatialForce {
    pub force: PxVec3,
    pub pad0: f32,
    pub torque: PxVec3,
    pub pad1: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSpatialVelocity {
    pub linear: PxVec3,
    pub pad0: f32,
    pub angular: PxVec3,
    pub pad1: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationRootLinkData {
    pub transform: PxTransform,
    pub worldLinVel: PxVec3,
    pub worldAngVel: PxVec3,
    pub worldLinAccel: PxVec3,
    pub worldAngAccel: PxVec3,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationCache {
    pub externalForces: *mut PxSpatialForce,
    pub denseJacobian: *mut f32,
    pub massMatrix: *mut f32,
    pub jointVelocity: *mut f32,
    pub jointAcceleration: *mut f32,
    pub jointPosition: *mut f32,
    pub jointForce: *mut f32,
    pub jointSolverForces: *mut f32,
    pub linkVelocity: *mut PxSpatialVelocity,
    pub linkAcceleration: *mut PxSpatialVelocity,
    pub rootLinkData: *mut PxArticulationRootLinkData,
    pub sensorForces: *mut PxSpatialForce,
    pub coefficientMatrix: *mut f32,
    pub lambda: *mut f32,
    pub scratchMemory: *mut std::ffi::c_void,
    pub scratchAllocator: *mut std::ffi::c_void,
    pub version: u32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationSensor {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationReducedCoordinate {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationJointReducedCoordinate {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxShape {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRigidActor {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxNodeIndex {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRigidBody {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxArticulationLink {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConeLimitedConstraint {
    pub mAxis: PxVec3,
    pub mAngle: f32,
    pub mLowLimit: f32,
    pub mHighLimit: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConeLimitParams {
    pub lowHighLimits: PxVec4,
    pub axisAngle: PxVec4,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConstraintShaderTable {
    pub solverPrep: PxU32 (*)(physx::Px1DConstraint *, physx::PxVec3p &, physx::PxU32, physx::PxConstraintInvMassScale &, const void *, const physx::PxTransform &, const physx::PxTransform &, bool, physx::PxVec3p &, physx::PxVec3p &),
    pub project: PxConstraintProject,
    pub visualize: PxConstraintVisualize,
    pub flag: PxConstraintFlag,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConstraint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMassModificationProps {
    pub mInvMassScale0: f32,
    pub mInvInertiaScale0: f32,
    pub mInvMassScale1: f32,
    pub mInvInertiaScale1: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPatch {
    pub mMassModification: PxMassModificationProps,
    pub normal: PxVec3,
    pub restitution: f32,
    pub dynamicFriction: f32,
    pub staticFriction: f32,
    pub damping: f32,
    pub startContactIndex: u16,
    pub nbContacts: u8,
    pub materialFlags: u8,
    pub internalFlags: u16,
    pub materialIndex0: u16,
    pub materialIndex1: u16,
    pub pad: [u16; 5],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContact {
    pub contact: PxVec3,
    pub separation: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxExtendedContact {
    pub contact: PxVec3,
    pub separation: f32,
    pub targetVelocity: PxVec3,
    pub maxImpulse: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxModifiableContact {
    pub contact: PxVec3,
    pub separation: f32,
    pub targetVelocity: PxVec3,
    pub maxImpulse: f32,
    pub normal: PxVec3,
    pub restitution: f32,
    pub materialFlags: u32,
    pub materialIndex0: u16,
    pub materialIndex1: u16,
    pub staticFriction: f32,
    pub dynamicFriction: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactStreamIterator {
    pub zero: PxVec3,
    pub structgen_pad0: [u8; 4],
    pub patch: *const PxContactPatch,
    pub contact: *const PxContact,
    pub faceIndice: *const u32,
    pub totalPatches: u32,
    pub totalContacts: u32,
    pub nextContactIndex: u32,
    pub nextPatchIndex: u32,
    pub contactPatchHeaderSize: u32,
    pub contactPointSize: u32,
    pub mStreamFormat: StreamFormat,
    pub forceNoResponse: u32,
    pub pointStepped: bool,
    pub structgen_pad1: [u8; 3],
    pub hasFaceIndices: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGpuContactPair {
    pub contactPatches: *mut u8,
    pub contactPoints: *mut u8,
    pub contactForces: *mut f32,
    pub transformCacheRef0: u32,
    pub transformCacheRef1: u32,
    pub nodeIndex0: PxNodeIndex,
    pub nodeIndex1: PxNodeIndex,
    pub actor0: *mut PxActor,
    pub actor1: *mut PxActor,
    pub nbContacts: u16,
    pub nbPatches: u16,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactSet {
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactModifyPair {
    pub actor: [*const PxRigidActor; 2],
    pub shape: [*const PxShape; 2],
    pub transform: [PxTransform; 2],
    pub contacts: PxContactSet,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBaseMaterial {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxFEMMaterial {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxFEMSoftBodyMaterial {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxFilterData {
    pub word0: u32,
    pub word1: u32,
    pub word2: u32,
    pub word3: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleRigidFilterPair {
    pub mID0: u64,
    pub mID1: u64,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMaterial {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGpuParticleBufferIndexPair {
    pub systemIndex: u32,
    pub bufferIndex: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleVolume {
    pub bound: PxBounds3,
    pub particleIndicesOffset: u32,
    pub numParticles: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleBuffer {
    pub structgen_pad0: [u8; 16],
    pub bufferIndex: u32,
    pub bufferUniqueId: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDiffuseParticleParams {
    pub threshold: f32,
    pub lifetime: f32,
    pub airDrag: f32,
    pub bubbleDrag: f32,
    pub buoyancy: f32,
    pub kineticEnergyWeight: f32,
    pub pressureWeight: f32,
    pub divergenceWeight: f32,
    pub collisionDecay: f32,
    pub useAccurateVelocity: bool,
    pub structgen_pad0: [u8; 3],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleAndDiffuseBuffer {
    pub structgen_pad0: [u8; 16],
    pub bufferIndex: u32,
    pub bufferUniqueId: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleSpring {
    pub ind0: u32,
    pub ind1: u32,
    pub length: f32,
    pub stiffness: f32,
    pub damping: f32,
    pub pad: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleCloth {
    pub startVertexIndex: u32,
    pub numVertices: u32,
    pub clothBlendScale: f32,
    pub restVolume: f32,
    pub pressure: f32,
    pub startTriangleIndex: u32,
    pub numTriangles: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleClothDesc {
    pub cloths: *mut PxParticleCloth,
    pub triangles: *mut u32,
    pub springs: *mut PxParticleSpring,
    pub restPositions: *mut PxVec4,
    pub nbCloths: u32,
    pub nbSprings: u32,
    pub nbTriangles: u32,
    pub nbParticles: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxPartitionedParticleCloth {
    pub accumulatedSpringsPerPartitions: *mut u32,
    pub accumulatedCopiesPerParticles: *mut u32,
    pub remapOutput: *mut u32,
    pub orderedSprings: *mut PxParticleSpring,
    pub sortedClothStartIndices: *mut u32,
    pub cloths: *mut PxParticleCloth,
    pub remapOutputSize: u32,
    pub nbPartitions: u32,
    pub nbSprings: u32,
    pub nbCloths: u32,
    pub maxSpringsPerPartition: u32,
    pub structgen_pad0: [u8; 4],
    pub mCudaManager: *mut PxCudaContextManager,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleClothBuffer {
    pub structgen_pad0: [u8; 16],
    pub bufferIndex: u32,
    pub bufferUniqueId: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleRigidBuffer {
    pub structgen_pad0: [u8; 16],
    pub bufferIndex: u32,
    pub bufferUniqueId: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxParticleMaterial {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxPBDMaterial {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCustomMaterial {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxActorShape {
    pub actor: *mut PxRigidActor,
    pub shape: *mut PxShape,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRaycastHit {
    pub faceIndex: u32,
    pub flags: PxHitFlags,
    pub structgen_pad0: [u8; 2],
    pub position: PxVec3,
    pub normal: PxVec3,
    pub distance: f32,
    pub u: f32,
    pub v: f32,
    pub structgen_pad1: [u8; 4],
    pub actor: *mut PxRigidActor,
    pub shape: *mut PxShape,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxOverlapHit {
    pub faceIndex: u32,
    pub structgen_pad0: [u8; 4],
    pub actor: *mut PxRigidActor,
    pub shape: *mut PxShape,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSweepHit {
    pub faceIndex: u32,
    pub flags: PxHitFlags,
    pub structgen_pad0: [u8; 2],
    pub position: PxVec3,
    pub normal: PxVec3,
    pub distance: f32,
    pub structgen_pad1: [u8; 4],
    pub actor: *mut PxRigidActor,
    pub shape: *mut PxShape,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxQueryCache {
    pub shape: *mut PxShape,
    pub actor: *mut PxRigidActor,
    pub faceIndex: u32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxQueryFilterData {
    pub data: PxFilterData,
    pub flags: PxQueryFlags,
    pub structgen_pad0: [u8; 2],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRigidDynamic {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRigidStatic {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSceneQueryDesc {
    pub staticStructure: PxPruningStructureType,
    pub dynamicStructure: PxPruningStructureType,
    pub dynamicTreeRebuildRateHint: u32,
    pub dynamicTreeSecondaryPruner: PxDynamicTreeSecondaryPruner,
    pub staticBVHBuildStrategy: PxBVHBuildStrategy,
    pub dynamicBVHBuildStrategy: PxBVHBuildStrategy,
    pub staticNbObjectsPerNode: u32,
    pub dynamicNbObjectsPerNode: u32,
    pub sceneQueryUpdateMode: PxSceneQueryUpdateMode,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhaseRegion {
    pub mBounds: PxBounds3,
    pub mUserData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhaseRegionInfo {
    pub mRegion: PxBroadPhaseRegion,
    pub mNbStaticObjects: u32,
    pub mNbDynamicObjects: u32,
    pub mActive: bool,
    pub mOverlap: bool,
    pub structgen_pad0: [u8; 6],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhaseCaps {
    pub mMaxNbRegions: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhaseDesc {
    pub mType: PxBroadPhaseType,
    pub structgen_pad0: [u8; 4],
    pub mContextID: u64,
    pub mContextManager: *mut PxCudaContextManager,
    pub mFoundLostPairsCapacity: u32,
    pub mDiscardStaticVsKinematic: bool,
    pub mDiscardKinematicVsKinematic: bool,
    pub structgen_pad1: [u8; 2],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhaseUpdateData {
    pub mCreated: *const u32,
    pub mNbCreated: u32,
    pub structgen_pad0: [u8; 4],
    pub mUpdated: *const u32,
    pub mNbUpdated: u32,
    pub structgen_pad1: [u8; 4],
    pub mRemoved: *const u32,
    pub mNbRemoved: u32,
    pub structgen_pad2: [u8; 4],
    pub mBounds: *const PxBounds3,
    pub mGroups: *const u32,
    pub mDistances: *const f32,
    pub mCapacity: u32,
    pub structgen_pad3: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhasePair {
    pub mID0: u32,
    pub mID1: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhaseResults {
    pub mNbCreatedPairs: u32,
    pub structgen_pad0: [u8; 4],
    pub mCreatedPairs: *const PxBroadPhasePair,
    pub mNbDeletedPairs: u32,
    pub structgen_pad1: [u8; 4],
    pub mDeletedPairs: *const PxBroadPhasePair,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSceneLimits {
    pub maxNbActors: u32,
    pub maxNbBodies: u32,
    pub maxNbStaticShapes: u32,
    pub maxNbDynamicShapes: u32,
    pub maxNbAggregates: u32,
    pub maxNbConstraints: u32,
    pub maxNbRegions: u32,
    pub maxNbBroadPhaseOverlaps: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxgDynamicsMemoryConfig {
    pub tempBufferCapacity: u32,
    pub maxRigidContactCount: u32,
    pub maxRigidPatchCount: u32,
    pub heapCapacity: u32,
    pub foundLostPairsCapacity: u32,
    pub foundLostAggregatePairsCapacity: u32,
    pub totalAggregatePairsCapacity: u32,
    pub maxSoftBodyContacts: u32,
    pub maxFemClothContacts: u32,
    pub maxParticleContacts: u32,
    pub collisionStackSize: u32,
    pub maxHairContacts: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSceneDesc {
    pub staticStructure: PxPruningStructureType,
    pub dynamicStructure: PxPruningStructureType,
    pub dynamicTreeRebuildRateHint: u32,
    pub dynamicTreeSecondaryPruner: PxDynamicTreeSecondaryPruner,
    pub staticBVHBuildStrategy: PxBVHBuildStrategy,
    pub dynamicBVHBuildStrategy: PxBVHBuildStrategy,
    pub staticNbObjectsPerNode: u32,
    pub dynamicNbObjectsPerNode: u32,
    pub sceneQueryUpdateMode: PxSceneQueryUpdateMode,
    pub gravity: PxVec3,
    pub simulationEventCallback: *mut PxSimulationEventCallback,
    pub contactModifyCallback: *mut PxContactModifyCallback,
    pub ccdContactModifyCallback: *mut PxCCDContactModifyCallback,
    pub filterShaderData: *const std::ffi::c_void,
    pub filterShaderDataSize: u32,
    pub structgen_pad0: [u8; 4],
    pub filterShader: PxFilterFlags (*)(physx::PxFilterObjectAttributes, physx::PxFilterData, physx::PxFilterObjectAttributes, physx::PxFilterData, physx::PxPairFlags &, const void *, physx::PxU32),
    pub filterCallback: *mut PxSimulationFilterCallback,
    pub kineKineFilteringMode: PxPairFilteringMode,
    pub staticKineFilteringMode: PxPairFilteringMode,
    pub broadPhaseType: PxBroadPhaseType,
    pub structgen_pad1: [u8; 4],
    pub broadPhaseCallback: *mut PxBroadPhaseCallback,
    pub limits: PxSceneLimits,
    pub frictionType: PxFrictionType,
    pub solverType: PxSolverType,
    pub bounceThresholdVelocity: f32,
    pub frictionOffsetThreshold: f32,
    pub frictionCorrelationDistance: f32,
    pub flags: PxSceneFlags,
    pub cpuDispatcher: *mut PxCpuDispatcher,
    pub cudaContextManager: *mut PxCudaContextManager,
    pub userData: *mut std::ffi::c_void,
    pub solverBatchSize: u32,
    pub solverArticulationBatchSize: u32,
    pub nbContactDataBlocks: u32,
    pub maxNbContactDataBlocks: u32,
    pub maxBiasCoefficient: f32,
    pub contactReportStreamBufferSize: u32,
    pub ccdMaxPasses: u32,
    pub ccdThreshold: f32,
    pub ccdMaxSeparation: f32,
    pub wakeCounterResetValue: f32,
    pub sanityBounds: PxBounds3,
    pub gpuDynamicsConfig: PxgDynamicsMemoryConfig,
    pub gpuMaxNumPartitions: u32,
    pub gpuMaxNumStaticPartitions: u32,
    pub gpuComputeVersion: u32,
    pub contactPairSlabSize: u32,
    pub sceneQuerySystem: *mut PxSceneQuerySystem,
    pub structgen_pad2: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSimulationStatistics {
    pub nbActiveConstraints: u32,
    pub nbActiveDynamicBodies: u32,
    pub nbActiveKinematicBodies: u32,
    pub nbStaticBodies: u32,
    pub nbDynamicBodies: u32,
    pub nbKinematicBodies: u32,
    pub nbShapes: [u32; 11],
    pub nbAggregates: u32,
    pub nbArticulations: u32,
    pub nbAxisSolverConstraints: u32,
    pub compressedContactSize: u32,
    pub requiredContactConstraintMemory: u32,
    pub peakConstraintMemory: u32,
    pub nbDiscreteContactPairsTotal: u32,
    pub nbDiscreteContactPairsWithCacheHits: u32,
    pub nbDiscreteContactPairsWithContacts: u32,
    pub nbNewPairs: u32,
    pub nbLostPairs: u32,
    pub nbNewTouches: u32,
    pub nbLostTouches: u32,
    pub nbPartitions: u32,
    pub structgen_pad0: [u8; 4],
    pub gpuMemParticles: u64,
    pub gpuMemSoftBodies: u64,
    pub gpuMemFEMCloths: u64,
    pub gpuMemHairSystems: u64,
    pub gpuMemHeap: u64,
    pub gpuMemHeapBroadPhase: u64,
    pub gpuMemHeapNarrowPhase: u64,
    pub gpuMemHeapSolver: u64,
    pub gpuMemHeapArticulation: u64,
    pub gpuMemHeapSimulation: u64,
    pub gpuMemHeapSimulationArticulation: u64,
    pub gpuMemHeapSimulationParticles: u64,
    pub gpuMemHeapSimulationSoftBody: u64,
    pub gpuMemHeapSimulationFEMCloth: u64,
    pub gpuMemHeapSimulationHairSystem: u64,
    pub gpuMemHeapParticles: u64,
    pub gpuMemHeapSoftBodies: u64,
    pub gpuMemHeapFEMCloths: u64,
    pub gpuMemHeapHairSystems: u64,
    pub gpuMemHeapOther: u64,
    pub nbBroadPhaseAdds: u32,
    pub nbBroadPhaseRemoves: u32,
    pub nbDiscreteContactPairs: [[u32; 11]; 11],
    pub nbCCDPairs: [[u32; 11]; 11],
    pub nbModifiedContactPairs: [[u32; 11]; 11],
    pub nbTriggerPairs: [[u32; 11]; 11],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGpuBodyData {
    pub quat: PxQuat,
    pub pos: PxVec4,
    pub linVel: PxVec4,
    pub angVel: PxVec4,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGpuActorPair {
    pub srcIndex: u32,
    pub structgen_pad0: [u8; 4],
    pub nodeIndex: PxNodeIndex,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxIndexDataPair {
    pub index: u32,
    pub structgen_pad0: [u8; 4],
    pub data: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDominanceGroupPair {
    pub dominance0: u8,
    pub dominance1: u8,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxScene {
    pub structgen_pad0: [u8; 8],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSceneReadLock {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSceneWriteLock {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPairExtraDataItem {
    pub type: u8,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPairVelocity {
    pub type: u8,
    pub structgen_pad0: [u8; 3],
    pub linearVelocity: [PxVec3; 2],
    pub angularVelocity: [PxVec3; 2],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPairPose {
    pub type: u8,
    pub structgen_pad0: [u8; 3],
    pub globalPose: [PxTransform; 2],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPairIndex {
    pub type: u8,
    pub structgen_pad0: [u8; 1],
    pub index: u16,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPairExtraDataIterator {
    pub currPtr: *const u8,
    pub endPtr: *const u8,
    pub preSolverVelocity: *const PxContactPairVelocity,
    pub postSolverVelocity: *const PxContactPairVelocity,
    pub eventPose: *const PxContactPairPose,
    pub contactPairIndex: u32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPairHeader {
    pub actors: [*mut PxActor; 2],
    pub extraDataStream: *const u8,
    pub extraDataStreamSize: u16,
    pub flags: PxContactPairHeaderFlags,
    pub structgen_pad0: [u8; 4],
    pub pairs: *const PxContactPair,
    pub nbPairs: u32,
    pub structgen_pad1: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPairPoint {
    pub position: PxVec3,
    pub separation: f32,
    pub normal: PxVec3,
    pub internalFaceIndex0: u32,
    pub impulse: PxVec3,
    pub internalFaceIndex1: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactPair {
    pub shapes: [*mut PxShape; 2],
    pub contactPatches: *const u8,
    pub contactPoints: *const u8,
    pub contactImpulses: *const f32,
    pub requiredBufferSize: u32,
    pub contactCount: u8,
    pub patchCount: u8,
    pub contactStreamSize: u16,
    pub flags: PxContactPairFlags,
    pub events: PxPairFlags,
    pub internalData: [u32; 2],
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTriggerPair {
    pub triggerShape: *mut PxShape,
    pub triggerActor: *mut PxActor,
    pub otherShape: *mut PxShape,
    pub otherActor: *mut PxActor,
    pub status: PxPairFlag,
    pub flags: PxTriggerPairFlags,
    pub structgen_pad0: [u8; 3],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConstraintInfo {
    pub constraint: *mut PxConstraint,
    pub externalReference: *mut std::ffi::c_void,
    pub type: u32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxFEMParameters {
    pub velocityDamping: f32,
    pub settlingThreshold: f32,
    pub sleepThreshold: f32,
    pub sleepDamping: f32,
    pub selfCollisionFilterDistance: f32,
    pub selfCollisionStressTolerance: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSoftBody {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxExtendedVec3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxObstacle {
    pub structgen_pad0: [u8; 8],
    pub mUserData: *mut std::ffi::c_void,
    pub mPos: PxExtendedVec3,
    pub mRot: PxQuat,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBoxObstacle {
    pub structgen_pad0: [u8; 8],
    pub mUserData: *mut std::ffi::c_void,
    pub mPos: PxExtendedVec3,
    pub mRot: PxQuat,
    pub mHalfExtents: PxVec3,
    pub structgen_pad1: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCapsuleObstacle {
    pub structgen_pad0: [u8; 8],
    pub mUserData: *mut std::ffi::c_void,
    pub mPos: PxExtendedVec3,
    pub mRot: PxQuat,
    pub mHalfHeight: f32,
    pub mRadius: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllerState {
    pub deltaXP: PxVec3,
    pub structgen_pad0: [u8; 4],
    pub touchedShape: *mut PxShape,
    pub touchedActor: *mut PxRigidActor,
    pub touchedObstacleHandle: u32,
    pub collisionFlags: u32,
    pub standOnAnotherCCT: bool,
    pub standOnObstacle: bool,
    pub isMovingUp: bool,
    pub structgen_pad1: [u8; 5],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllerStats {
    pub nbIterations: u16,
    pub nbFullUpdates: u16,
    pub nbPartialUpdates: u16,
    pub nbTessellation: u16,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllerHit {
    pub controller: *mut PxController,
    pub worldPos: PxExtendedVec3,
    pub worldNormal: PxVec3,
    pub dir: PxVec3,
    pub length: f32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllerShapeHit {
    pub controller: *mut PxController,
    pub worldPos: PxExtendedVec3,
    pub worldNormal: PxVec3,
    pub dir: PxVec3,
    pub length: f32,
    pub structgen_pad0: [u8; 4],
    pub shape: *mut PxShape,
    pub actor: *mut PxRigidActor,
    pub triangleIndex: u32,
    pub structgen_pad1: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllersHit {
    pub controller: *mut PxController,
    pub worldPos: PxExtendedVec3,
    pub worldNormal: PxVec3,
    pub dir: PxVec3,
    pub length: f32,
    pub structgen_pad0: [u8; 4],
    pub other: *mut PxController,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllerObstacleHit {
    pub controller: *mut PxController,
    pub worldPos: PxExtendedVec3,
    pub worldNormal: PxVec3,
    pub dir: PxVec3,
    pub length: f32,
    pub structgen_pad0: [u8; 4],
    pub userData: *const std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllerFilters {
    pub mFilterData: *const PxFilterData,
    pub mFilterCallback: *mut PxQueryFilterCallback,
    pub mFilterFlags: PxQueryFlags,
    pub structgen_pad0: [u8; 6],
    pub mCCTFilterCallback: *mut PxControllerFilterCallback,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxControllerDesc {
    pub structgen_pad0: [u8; 8],
    pub position: PxExtendedVec3,
    pub upDirection: PxVec3,
    pub slopeLimit: f32,
    pub invisibleWallHeight: f32,
    pub maxJumpHeight: f32,
    pub contactOffset: f32,
    pub stepOffset: f32,
    pub density: f32,
    pub scaleCoeff: f32,
    pub volumeGrowth: f32,
    pub structgen_pad1: [u8; 4],
    pub reportCallback: *mut PxUserControllerHitReport,
    pub behaviorCallback: *mut PxControllerBehaviorCallback,
    pub nonWalkableMode: PxControllerNonWalkableMode,
    pub structgen_pad2: [u8; 4],
    pub material: *mut PxMaterial,
    pub registerDeletionListener: bool,
    pub clientID: u8,
    pub structgen_pad3: [u8; 6],
    pub userData: *mut std::ffi::c_void,
    pub structgen_pad4: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBoxControllerDesc {
    pub structgen_pad0: [u8; 8],
    pub position: PxExtendedVec3,
    pub upDirection: PxVec3,
    pub slopeLimit: f32,
    pub invisibleWallHeight: f32,
    pub maxJumpHeight: f32,
    pub contactOffset: f32,
    pub stepOffset: f32,
    pub density: f32,
    pub scaleCoeff: f32,
    pub volumeGrowth: f32,
    pub structgen_pad1: [u8; 4],
    pub reportCallback: *mut PxUserControllerHitReport,
    pub behaviorCallback: *mut PxControllerBehaviorCallback,
    pub nonWalkableMode: PxControllerNonWalkableMode,
    pub structgen_pad2: [u8; 4],
    pub material: *mut PxMaterial,
    pub registerDeletionListener: bool,
    pub clientID: u8,
    pub structgen_pad3: [u8; 6],
    pub userData: *mut std::ffi::c_void,
    pub structgen_pad4: [u8; 4],
    pub halfHeight: f32,
    pub halfSideExtent: f32,
    pub halfForwardExtent: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCapsuleControllerDesc {
    pub structgen_pad0: [u8; 8],
    pub position: PxExtendedVec3,
    pub upDirection: PxVec3,
    pub slopeLimit: f32,
    pub invisibleWallHeight: f32,
    pub maxJumpHeight: f32,
    pub contactOffset: f32,
    pub stepOffset: f32,
    pub density: f32,
    pub scaleCoeff: f32,
    pub volumeGrowth: f32,
    pub structgen_pad1: [u8; 4],
    pub reportCallback: *mut PxUserControllerHitReport,
    pub behaviorCallback: *mut PxControllerBehaviorCallback,
    pub nonWalkableMode: PxControllerNonWalkableMode,
    pub structgen_pad2: [u8; 4],
    pub material: *mut PxMaterial,
    pub registerDeletionListener: bool,
    pub clientID: u8,
    pub structgen_pad3: [u8; 6],
    pub userData: *mut std::ffi::c_void,
    pub structgen_pad4: [u8; 4],
    pub radius: f32,
    pub height: f32,
    pub climbingMode: PxCapsuleClimbingMode,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDim3 {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSDFDesc {
    pub sdf: PxBoundedData,
    pub dims: PxDim3,
    pub meshLower: PxVec3,
    pub spacing: f32,
    pub subgridSize: u32,
    pub bitsPerSubgridPixel: PxSdfBitsPerSubgridPixel,
    pub sdfSubgrids3DTexBlockDim: PxDim3,
    pub sdfSubgrids: PxBoundedData,
    pub sdfStartSlots: PxBoundedData,
    pub subgridsMinSdfValue: f32,
    pub subgridsMaxSdfValue: f32,
    pub sdfBounds: PxBounds3,
    pub narrowBandThicknessRelativeToSdfBoundsDiagonal: f32,
    pub numThreadsForSdfConstruction: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxConvexMeshDesc {
    pub points: PxBoundedData,
    pub polygons: PxBoundedData,
    pub indices: PxBoundedData,
    pub flags: PxConvexFlags,
    pub vertexLimit: u16,
    pub polygonLimit: u16,
    pub quantizedCount: u16,
    pub sdfDesc: *mut PxSDFDesc,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTriangleMeshDesc {
    pub points: PxBoundedData,
    pub triangles: PxBoundedData,
    pub flags: PxMeshFlags,
    pub structgen_pad0: [u8; 22],
    pub sdfDesc: *mut PxSDFDesc,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTetrahedronMeshDesc {
    pub structgen_pad0: [u8; 16],
    pub points: PxBoundedData,
    pub tetrahedrons: PxBoundedData,
    pub flags: PxMeshFlags,
    pub tetsPerElement: u16,
    pub structgen_pad1: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSoftBodySimulationDataDesc {
    pub vertexToTet: PxBoundedData,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBVH33MidphaseDesc {
    pub meshSizePerformanceTradeOff: f32,
    pub meshCookingHint: PxMeshCookingHint,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBVH34MidphaseDesc {
    pub numPrimsPerLeaf: u32,
    pub buildStrategy: PxBVH34BuildStrategy,
    pub quantized: bool,
    pub structgen_pad0: [u8; 3],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMidphaseDesc {
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBVHDesc {
    pub bounds: PxBoundedData,
    pub enlargement: f32,
    pub numPrimsPerLeaf: u32,
    pub buildStrategy: PxBVHBuildStrategy,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxCookingParams {
    pub areaTestEpsilon: f32,
    pub planeTolerance: f32,
    pub convexMeshCookingType: PxConvexMeshCookingType,
    pub suppressTriangleMeshRemapTable: bool,
    pub buildTriangleAdjacencies: bool,
    pub buildGPUData: bool,
    pub structgen_pad0: [u8; 1],
    pub scale: PxTolerancesScale,
    pub meshPreprocessParams: PxMeshPreprocessingFlags,
    pub meshWeldTolerance: f32,
    pub midphaseDesc: PxMidphaseDesc,
    pub gaussMapLimit: u32,
    pub maxWeightRatioInTet: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSpring {
    pub stiffness: f32,
    pub damping: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxDistanceJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJacobianRow {
    pub linear0: PxVec3,
    pub linear1: PxVec3,
    pub angular0: PxVec3,
    pub angular1: PxVec3,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxContactJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxFixedJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJointLimitParameters {
    pub restitution: f32,
    pub bounceThreshold: f32,
    pub stiffness: f32,
    pub damping: f32,
    pub contactDistance_deprecated: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJointLinearLimit {
    pub restitution: f32,
    pub bounceThreshold: f32,
    pub stiffness: f32,
    pub damping: f32,
    pub contactDistance_deprecated: f32,
    pub value: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJointLinearLimitPair {
    pub restitution: f32,
    pub bounceThreshold: f32,
    pub stiffness: f32,
    pub damping: f32,
    pub contactDistance_deprecated: f32,
    pub upper: f32,
    pub lower: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJointAngularLimitPair {
    pub restitution: f32,
    pub bounceThreshold: f32,
    pub stiffness: f32,
    pub damping: f32,
    pub contactDistance_deprecated: f32,
    pub upper: f32,
    pub lower: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJointLimitCone {
    pub restitution: f32,
    pub bounceThreshold: f32,
    pub stiffness: f32,
    pub damping: f32,
    pub contactDistance_deprecated: f32,
    pub yAngle: f32,
    pub zAngle: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxJointLimitPyramid {
    pub restitution: f32,
    pub bounceThreshold: f32,
    pub stiffness: f32,
    pub damping: f32,
    pub contactDistance_deprecated: f32,
    pub yAngleMin: f32,
    pub yAngleMax: f32,
    pub zAngleMin: f32,
    pub zAngleMax: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxPrismaticJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRevoluteJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSphericalJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxD6JointDrive {
    pub stiffness: f32,
    pub damping: f32,
    pub forceLimit: f32,
    pub flags: PxD6JointDriveFlags,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxD6Joint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGearJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRackAndPinionJoint {
    pub structgen_pad0: [u8; 16],
    pub userData: *mut std::ffi::c_void,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxGroupsMask {
    pub bits0: u16,
    pub bits1: u16,
    pub bits2: u16,
    pub bits3: u16,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRigidActorExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMassProperties {
    pub inertiaTensor: PxMat33,
    pub centerOfMass: PxVec3,
    pub mass: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRigidBodyExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxShapeExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxMeshOverlapUtil {
    pub structgen_pad0: [u8; 1040],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSerialization {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxStringTableExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBroadPhaseExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSceneQueryExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxBatchQueryStatus {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxSamplingExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxPoissonSampler {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTriangleMeshPoissonSampler {
    pub structgen_pad0: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxTetrahedronMeshExt {
    pub structgen_pad0: [u8; 1],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRepXObject {
    pub typeName: *const std::ffi::c_char,
    pub serializable: *const std::ffi::c_void,
    pub id: u64,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxRepXInstantiationArgs {
    pub structgen_pad0: [u8; 8],
    pub cooker: *mut PxCooking,
    pub stringTable: *mut PxStringTable,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleContext {
    pub upAxis: PxVec3,
    pub forwardAxis: PxVec3,
    pub sideAxis: PxVec3,
    pub updateMode: PxVehicleUpdateMode,
    pub pointRejectAngleThresholdCosine: f32,
    pub normalRejectAngleThresholdCosine: f32,
    pub maxHitActorAcceleration: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleChassisData {
    pub mMOI: PxVec3,
    pub mMass: f32,
    pub mCMOffset: PxVec3,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleEngineData {
    pub structgen_pad0: [u8; 80],
    pub mMOI: f32,
    pub mPeakTorque: f32,
    pub mMaxOmega: f32,
    pub mDampingRateFullThrottle: f32,
    pub mDampingRateZeroThrottleClutchEngaged: f32,
    pub mDampingRateZeroThrottleClutchDisengaged: f32,
    pub structgen_pad1: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleGearsData {
    pub mRatios: [f32; 32],
    pub mFinalRatio: f32,
    pub mNbRatios: u32,
    pub mSwitchTime: f32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleAutoBoxData {
    pub mUpRatios: [f32; 32],
    pub mDownRatios: [f32; 32],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDifferential4WData {
    pub mFrontRearSplit: f32,
    pub mFrontLeftRightSplit: f32,
    pub mRearLeftRightSplit: f32,
    pub mCentreBias: f32,
    pub mFrontBias: f32,
    pub mRearBias: f32,
    pub mType: Enum,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDifferentialNWData {
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleAckermannGeometryData {
    pub mAccuracy: f32,
    pub mFrontWidth: f32,
    pub mRearWidth: f32,
    pub mAxleSeparation: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleClutchData {
    pub mStrength: f32,
    pub mAccuracyMode: PxVehicleClutchAccuracyMode,
    pub mEstimateIterations: u32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleTireLoadFilterData {
    pub mMinNormalisedLoad: f32,
    pub mMinFilteredNormalisedLoad: f32,
    pub mMaxNormalisedLoad: f32,
    pub mMaxFilteredNormalisedLoad: f32,
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleWheelData {
    pub mRadius: f32,
    pub mWidth: f32,
    pub mMass: f32,
    pub mMOI: f32,
    pub mDampingRate: f32,
    pub mMaxBrakeTorque: f32,
    pub mMaxHandBrakeTorque: f32,
    pub mMaxSteer: f32,
    pub mToeAngle: f32,
    pub structgen_pad0: [u8; 12],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleSuspensionData {
    pub mSpringStrength: f32,
    pub mSpringDamperRate: f32,
    pub mMaxCompression: f32,
    pub mMaxDroop: f32,
    pub mSprungMass: f32,
    pub mCamberAtRest: f32,
    pub mCamberAtMaxCompression: f32,
    pub mCamberAtMaxDroop: f32,
    pub structgen_pad0: [u8; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleAntiRollBarData {
    pub mWheel0: u32,
    pub mWheel1: u32,
    pub mStiffness: f32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleTireData {
    pub mLatStiffX: f32,
    pub mLatStiffY: f32,
    pub mLongitudinalStiffnessPerUnitGravity: f32,
    pub mCamberStiffnessPerUnitGravity: f32,
    pub mFrictionVsSlipGraph: [[f32; 3]; 2],
    pub mType: u32,
    pub structgen_pad0: [u8; 20],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleWheelsSimData {
    pub structgen_pad0: [u8; 96],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleWheelsDynData {
    pub structgen_pad0: [u8; 48],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleWheels {
    pub structgen_pad0: [u8; 16],
    pub mWheelsSimData: PxVehicleWheelsSimData,
    pub mWheelsDynData: PxVehicleWheelsDynData,
    pub structgen_pad1: [u8; 32],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDriveSimData {
    pub structgen_pad0: [u8; 528],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDriveDynData {
    pub mControlAnalogVals: [f32; 16],
    pub mUseAutoGears: bool,
    pub mGearUpPressed: bool,
    pub mGearDownPressed: bool,
    pub structgen_pad0: [u8; 1],
    pub mCurrentGear: u32,
    pub mTargetGear: u32,
    pub mEnginespeed: f32,
    pub mGearSwitchTime: f32,
    pub mAutoBoxSwitchTime: f32,
    pub structgen_pad1: [u8; 8],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDrive {
    pub structgen_pad0: [u8; 16],
    pub mWheelsSimData: PxVehicleWheelsSimData,
    pub mWheelsDynData: PxVehicleWheelsDynData,
    pub structgen_pad1: [u8; 28],
    pub mDriveDynData: PxVehicleDriveDynData,
    pub structgen_pad2: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDriveSimData4W {
    pub structgen_pad0: [u8; 576],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDrive4W {
    pub structgen_pad0: [u8; 16],
    pub mWheelsSimData: PxVehicleWheelsSimData,
    pub mWheelsDynData: PxVehicleWheelsDynData,
    pub structgen_pad1: [u8; 28],
    pub mDriveDynData: PxVehicleDriveDynData,
    pub mDriveSimData: PxVehicleDriveSimData4W,
    pub structgen_pad2: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDriveTank {
    pub structgen_pad0: [u8; 16],
    pub mWheelsSimData: PxVehicleWheelsSimData,
    pub mWheelsDynData: PxVehicleWheelsDynData,
    pub structgen_pad1: [u8; 28],
    pub mDriveDynData: PxVehicleDriveDynData,
    pub mDriveSimData: PxVehicleDriveSimData,
    pub structgen_pad2: [u8; 20],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDrivableSurfaceType {
    pub mType: u32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDrivableSurfaceToTireFrictionPairs {
    pub structgen_pad0: [u8; 48],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxWheelQueryResult {
    pub suspLineStart: PxVec3,
    pub suspLineDir: PxVec3,
    pub suspLineLength: f32,
    pub isInAir: bool,
    pub structgen_pad0: [u8; 3],
    pub tireContactActor: *mut PxActor,
    pub tireContactShape: *mut PxShape,
    pub tireSurfaceMaterial: *const PxMaterial,
    pub tireSurfaceType: u32,
    pub tireContactPoint: PxVec3,
    pub tireContactNormal: PxVec3,
    pub tireFriction: f32,
    pub suspJounce: f32,
    pub suspSpringForce: f32,
    pub tireLongitudinalDir: PxVec3,
    pub tireLateralDir: PxVec3,
    pub longitudinalSlip: f32,
    pub lateralSlip: f32,
    pub steerAngle: f32,
    pub localPose: PxTransform,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleWheelQueryResult {
    pub wheelQueryResults: *mut PxWheelQueryResult,
    pub nbWheelQueryResults: u32,
    pub structgen_pad0: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleWheelConcurrentUpdateData {
    pub structgen_pad0: [u8; 64],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleConcurrentUpdateData {
    pub concurrentWheelUpdates: *mut PxVehicleWheelConcurrentUpdateData,
    pub nbConcurrentWheelUpdates: u32,
    pub structgen_pad0: [u8; 28],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDriveSimDataNW {
    pub structgen_pad0: [u8; 544],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDriveNW {
    pub structgen_pad0: [u8; 16],
    pub mWheelsSimData: PxVehicleWheelsSimData,
    pub mWheelsDynData: PxVehicleWheelsDynData,
    pub structgen_pad1: [u8; 28],
    pub mDriveDynData: PxVehicleDriveDynData,
    pub mDriveSimData: PxVehicleDriveSimDataNW,
    pub structgen_pad2: [u8; 4],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleSteerFilter {
    pub mSharpness: f32,
    pub mFilteredMaxSteer: f32,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleKeySmoothingData {
    pub mRiseRates: [f32; 16],
    pub mFallRates: [f32; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehiclePadSmoothingData {
    pub mRiseRates: [f32; 16],
    pub mFallRates: [f32; 16],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleDriveTankRawInputData {
    pub structgen_pad0: [u8; 32],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleCopyDynamicsMap {
    pub sourceWheelIds: [u8; 20],
    pub targetWheelIds: [u8; 20],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleGraphDesc {
    pub structgen_pad0: [u8; 32],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleGraphChannelDesc {
    pub mMinY: f32,
    pub mMaxY: f32,
    pub mMidY: f32,
    pub mColorLow: PxVec3,
    pub mColorHigh: PxVec3,
    pub structgen_pad0: [u8; 4],
    pub mTitle: *mut std::ffi::c_char,
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleGraph {
    pub structgen_pad0: [u8; 15840],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleTelemetryData {
    pub structgen_pad0: [u8; 48],
}
#[derive(Clone, Copy)]
#[repr(C)]
pub struct PxVehicleNoDrive {
    pub structgen_pad0: [u8; 16],
    pub mWheelsSimData: PxVehicleWheelsSimData,
    pub mWheelsDynData: PxVehicleWheelsDynData,
    pub structgen_pad1: [u8; 64],
}
#[cfg(test)]
mod sizes {
    #[test]
    fn check_sizes() {
        assert_eq!(std::mem::size_of::<PxVec3>(), 12);
        assert_eq!(std::mem::size_of::<PxVec4>(), 16);
        assert_eq!(std::mem::size_of::<PxQuat>(), 16);
        assert_eq!(std::mem::size_of::<PxMat33>(), 36);
        assert_eq!(std::mem::size_of::<PxMat44>(), 64);
        assert_eq!(std::mem::size_of::<PxTransform>(), 28);
        assert_eq!(std::mem::size_of::<PxAllocator>(), 1);
        assert_eq!(std::mem::size_of::<PxRawAllocator>(), 1);
        assert_eq!(std::mem::size_of::<PxVirtualAllocator>(), 16);
        assert_eq!(std::mem::size_of::<PxUserAllocated>(), 1);
        assert_eq!(std::mem::size_of::<PxTempAllocator>(), 1);
        assert_eq!(std::mem::size_of::<PxVec3Padded>(), 16);
        assert_eq!(std::mem::size_of::<PxTransformPadded>(), 32);
        assert_eq!(std::mem::size_of::<PxBounds3>(), 24);
        assert_eq!(std::mem::size_of::<PxFPUGuard>(), 32);
        assert_eq!(std::mem::size_of::<PxSIMDGuard>(), 8);
        assert_eq!(std::mem::size_of::<PxPlane>(), 16);
        assert_eq!(std::mem::size_of::<PxMutexImpl>(), 1);
        assert_eq!(std::mem::size_of::<PxReadWriteLock>(), 8);
        assert_eq!(std::mem::size_of::<PxProfileScoped>(), 40);
        assert_eq!(std::mem::size_of::<PxSListEntry>(), 16);
        assert_eq!(std::mem::size_of::<PxSListImpl>(), 1);
        assert_eq!(std::mem::size_of::<PxSocket>(), 16);
        assert_eq!(std::mem::size_of::<PxSyncImpl>(), 1);
        assert_eq!(std::mem::size_of::<PxThreadImpl>(), 1);
        assert_eq!(std::mem::size_of::<PxCounterFrequencyToTensOfNanos>(), 16);
        assert_eq!(std::mem::size_of::<PxTime>(), 8);
        assert_eq!(std::mem::size_of::<PxStridedData>(), 16);
        assert_eq!(std::mem::size_of::<PxBoundedData>(), 24);
        assert_eq!(std::mem::size_of::<PxDebugPoint>(), 16);
        assert_eq!(std::mem::size_of::<PxDebugLine>(), 32);
        assert_eq!(std::mem::size_of::<PxDebugTriangle>(), 48);
        assert_eq!(std::mem::size_of::<PxDebugText>(), 32);
        assert_eq!(std::mem::size_of::<PxTolerancesScale>(), 8);
        assert_eq!(std::mem::size_of::<PxMetaDataEntry>(), 40);
        assert_eq!(std::mem::size_of::<PxGeometry>(), 8);
        assert_eq!(std::mem::size_of::<PxBoxGeometry>(), 20);
        assert_eq!(std::mem::size_of::<PxCapsuleGeometry>(), 16);
        assert_eq!(std::mem::size_of::<PxHullPolygon>(), 20);
        assert_eq!(std::mem::size_of::<PxMeshScale>(), 28);
        assert_eq!(std::mem::size_of::<PxConvexMeshGeometry>(), 56);
        assert_eq!(std::mem::size_of::<PxSphereGeometry>(), 12);
        assert_eq!(std::mem::size_of::<PxPlaneGeometry>(), 8);
        assert_eq!(std::mem::size_of::<PxTriangleMeshGeometry>(), 48);
        assert_eq!(std::mem::size_of::<PxHeightFieldGeometry>(), 32);
        assert_eq!(std::mem::size_of::<PxParticleSystemGeometry>(), 12);
        assert_eq!(std::mem::size_of::<PxHairSystemGeometry>(), 8);
        assert_eq!(std::mem::size_of::<PxTetrahedronMeshGeometry>(), 16);
        assert_eq!(std::mem::size_of::<PxQueryHit>(), 4);
        assert_eq!(std::mem::size_of::<PxLocationHit>(), 36);
        assert_eq!(std::mem::size_of::<PxGeomRaycastHit>(), 44);
        assert_eq!(std::mem::size_of::<PxGeomOverlapHit>(), 4);
        assert_eq!(std::mem::size_of::<PxGeomSweepHit>(), 36);
        assert_eq!(std::mem::size_of::<PxGeomIndexPair>(), 8);
        assert_eq!(std::mem::size_of::<PxQueryThreadContext>(), 1);
        assert_eq!(std::mem::size_of::<PxCustomGeometry>(), 16);
        assert_eq!(std::mem::size_of::<PxGeometryHolder>(), 56);
        assert_eq!(std::mem::size_of::<PxGeometryQuery>(), 1);
        assert_eq!(std::mem::size_of::<PxHeightFieldSample>(), 4);
        assert_eq!(std::mem::size_of::<PxHeightFieldDesc>(), 40);
        assert_eq!(std::mem::size_of::<PxMeshQuery>(), 1);
        assert_eq!(std::mem::size_of::<PxSimpleTriangleMesh>(), 56);
        assert_eq!(std::mem::size_of::<PxTriangle>(), 36);
        assert_eq!(std::mem::size_of::<PxTrianglePadded>(), 40);
        assert_eq!(std::mem::size_of::<PxTetrahedron>(), 48);
        assert_eq!(std::mem::size_of::<PxCollisionMeshMappingData>(), 8);
        assert_eq!(std::mem::size_of::<PxSoftBodyCollisionData>(), 1);
        assert_eq!(std::mem::size_of::<PxTetrahedronMeshData>(), 1);
        assert_eq!(std::mem::size_of::<PxSoftBodySimulationData>(), 1);
        assert_eq!(std::mem::size_of::<PxCollisionTetrahedronMeshData>(), 8);
        assert_eq!(std::mem::size_of::<PxSimulationTetrahedronMeshData>(), 8);
        assert_eq!(std::mem::size_of::<PxActor>(), 24);
        assert_eq!(std::mem::size_of::<PxAggregate>(), 24);
        assert_eq!(std::mem::size_of::<PxSpringModifiers>(), 16);
        assert_eq!(std::mem::size_of::<PxRestitutionModifiers>(), 16);
        assert_eq!(std::mem::size_of::<Px1DConstraint>(), 96);
        assert_eq!(std::mem::size_of::<PxConstraintInvMassScale>(), 16);
        assert_eq!(std::mem::size_of::<PxContactPoint>(), 80);
        assert_eq!(std::mem::size_of::<PxSolverBody>(), 32);
        assert_eq!(std::mem::size_of::<PxSolverBodyData>(), 112);
        assert_eq!(std::mem::size_of::<PxConstraintBatchHeader>(), 8);
        assert_eq!(std::mem::size_of::<PxSolverConstraintDesc>(), 64);
        assert_eq!(std::mem::size_of::<PxSolverConstraintPrepDescBase>(), 128);
        assert_eq!(std::mem::size_of::<PxSolverConstraintPrepDesc>(), 192);
        assert_eq!(std::mem::size_of::<PxSolverContactDesc>(), 208);
        assert_eq!(std::mem::size_of::<PxArticulationLimit>(), 8);
        assert_eq!(std::mem::size_of::<PxArticulationDrive>(), 16);
        assert_eq!(std::mem::size_of::<PxTGSSolverBodyVel>(), 64);
        assert_eq!(std::mem::size_of::<PxTGSSolverBodyTxInertia>(), 64);
        assert_eq!(std::mem::size_of::<PxTGSSolverBodyData>(), 48);
        assert_eq!(std::mem::size_of::<PxTGSSolverConstraintPrepDescBase>(), 144);
        assert_eq!(std::mem::size_of::<PxTGSSolverConstraintPrepDesc>(), 224);
        assert_eq!(std::mem::size_of::<PxTGSSolverContactDesc>(), 224);
        assert_eq!(std::mem::size_of::<PxArticulationTendonLimit>(), 8);
        assert_eq!(std::mem::size_of::<PxArticulationAttachment>(), 24);
        assert_eq!(std::mem::size_of::<PxArticulationTendonJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxArticulationTendon>(), 24);
        assert_eq!(std::mem::size_of::<PxArticulationSpatialTendon>(), 24);
        assert_eq!(std::mem::size_of::<PxArticulationFixedTendon>(), 24);
        assert_eq!(std::mem::size_of::<PxSpatialForce>(), 32);
        assert_eq!(std::mem::size_of::<PxSpatialVelocity>(), 32);
        assert_eq!(std::mem::size_of::<PxArticulationRootLinkData>(), 76);
        assert_eq!(std::mem::size_of::<PxArticulationCache>(), 136);
        assert_eq!(std::mem::size_of::<PxArticulationSensor>(), 24);
        assert_eq!(std::mem::size_of::<PxArticulationReducedCoordinate>(), 24);
        assert_eq!(std::mem::size_of::<PxArticulationJointReducedCoordinate>(), 24);
        assert_eq!(std::mem::size_of::<PxShape>(), 24);
        assert_eq!(std::mem::size_of::<PxRigidActor>(), 24);
        assert_eq!(std::mem::size_of::<PxNodeIndex>(), 8);
        assert_eq!(std::mem::size_of::<PxRigidBody>(), 24);
        assert_eq!(std::mem::size_of::<PxArticulationLink>(), 24);
        assert_eq!(std::mem::size_of::<PxConeLimitedConstraint>(), 24);
        assert_eq!(std::mem::size_of::<PxConeLimitParams>(), 32);
        assert_eq!(std::mem::size_of::<PxConstraintShaderTable>(), 32);
        assert_eq!(std::mem::size_of::<PxConstraint>(), 24);
        assert_eq!(std::mem::size_of::<PxMassModificationProps>(), 16);
        assert_eq!(std::mem::size_of::<PxContactPatch>(), 64);
        assert_eq!(std::mem::size_of::<PxContact>(), 16);
        assert_eq!(std::mem::size_of::<PxExtendedContact>(), 32);
        assert_eq!(std::mem::size_of::<PxModifiableContact>(), 64);
        assert_eq!(std::mem::size_of::<PxContactStreamIterator>(), 80);
        assert_eq!(std::mem::size_of::<PxGpuContactPair>(), 72);
        assert_eq!(std::mem::size_of::<PxContactSet>(), 16);
        assert_eq!(std::mem::size_of::<PxContactModifyPair>(), 104);
        assert_eq!(std::mem::size_of::<PxBaseMaterial>(), 24);
        assert_eq!(std::mem::size_of::<PxFEMMaterial>(), 24);
        assert_eq!(std::mem::size_of::<PxFEMSoftBodyMaterial>(), 24);
        assert_eq!(std::mem::size_of::<PxFilterData>(), 16);
        assert_eq!(std::mem::size_of::<PxParticleRigidFilterPair>(), 16);
        assert_eq!(std::mem::size_of::<PxMaterial>(), 24);
        assert_eq!(std::mem::size_of::<PxGpuParticleBufferIndexPair>(), 8);
        assert_eq!(std::mem::size_of::<PxParticleVolume>(), 32);
        assert_eq!(std::mem::size_of::<PxParticleBuffer>(), 24);
        assert_eq!(std::mem::size_of::<PxDiffuseParticleParams>(), 40);
        assert_eq!(std::mem::size_of::<PxParticleAndDiffuseBuffer>(), 24);
        assert_eq!(std::mem::size_of::<PxParticleSpring>(), 24);
        assert_eq!(std::mem::size_of::<PxParticleCloth>(), 28);
        assert_eq!(std::mem::size_of::<PxParticleClothDesc>(), 48);
        assert_eq!(std::mem::size_of::<PxPartitionedParticleCloth>(), 80);
        assert_eq!(std::mem::size_of::<PxParticleClothBuffer>(), 24);
        assert_eq!(std::mem::size_of::<PxParticleRigidBuffer>(), 24);
        assert_eq!(std::mem::size_of::<PxParticleMaterial>(), 24);
        assert_eq!(std::mem::size_of::<PxPBDMaterial>(), 24);
        assert_eq!(std::mem::size_of::<PxCustomMaterial>(), 24);
        assert_eq!(std::mem::size_of::<PxActorShape>(), 16);
        assert_eq!(std::mem::size_of::<PxRaycastHit>(), 64);
        assert_eq!(std::mem::size_of::<PxOverlapHit>(), 24);
        assert_eq!(std::mem::size_of::<PxSweepHit>(), 56);
        assert_eq!(std::mem::size_of::<PxQueryCache>(), 24);
        assert_eq!(std::mem::size_of::<PxQueryFilterData>(), 20);
        assert_eq!(std::mem::size_of::<PxRigidDynamic>(), 24);
        assert_eq!(std::mem::size_of::<PxRigidStatic>(), 24);
        assert_eq!(std::mem::size_of::<PxSceneQueryDesc>(), 36);
        assert_eq!(std::mem::size_of::<PxBroadPhaseRegion>(), 32);
        assert_eq!(std::mem::size_of::<PxBroadPhaseRegionInfo>(), 48);
        assert_eq!(std::mem::size_of::<PxBroadPhaseCaps>(), 4);
        assert_eq!(std::mem::size_of::<PxBroadPhaseDesc>(), 32);
        assert_eq!(std::mem::size_of::<PxBroadPhaseUpdateData>(), 80);
        assert_eq!(std::mem::size_of::<PxBroadPhasePair>(), 8);
        assert_eq!(std::mem::size_of::<PxBroadPhaseResults>(), 32);
        assert_eq!(std::mem::size_of::<PxSceneLimits>(), 32);
        assert_eq!(std::mem::size_of::<PxgDynamicsMemoryConfig>(), 48);
        assert_eq!(std::mem::size_of::<PxSceneDesc>(), 352);
        assert_eq!(std::mem::size_of::<PxSimulationStatistics>(), 2232);
        assert_eq!(std::mem::size_of::<PxGpuBodyData>(), 64);
        assert_eq!(std::mem::size_of::<PxGpuActorPair>(), 16);
        assert_eq!(std::mem::size_of::<PxIndexDataPair>(), 16);
        assert_eq!(std::mem::size_of::<PxDominanceGroupPair>(), 2);
        assert_eq!(std::mem::size_of::<PxScene>(), 16);
        assert_eq!(std::mem::size_of::<PxSceneReadLock>(), 8);
        assert_eq!(std::mem::size_of::<PxSceneWriteLock>(), 8);
        assert_eq!(std::mem::size_of::<PxContactPairExtraDataItem>(), 1);
        assert_eq!(std::mem::size_of::<PxContactPairVelocity>(), 52);
        assert_eq!(std::mem::size_of::<PxContactPairPose>(), 60);
        assert_eq!(std::mem::size_of::<PxContactPairIndex>(), 4);
        assert_eq!(std::mem::size_of::<PxContactPairExtraDataIterator>(), 48);
        assert_eq!(std::mem::size_of::<PxContactPairHeader>(), 48);
        assert_eq!(std::mem::size_of::<PxContactPairPoint>(), 48);
        assert_eq!(std::mem::size_of::<PxContactPair>(), 64);
        assert_eq!(std::mem::size_of::<PxTriggerPair>(), 40);
        assert_eq!(std::mem::size_of::<PxConstraintInfo>(), 24);
        assert_eq!(std::mem::size_of::<PxFEMParameters>(), 24);
        assert_eq!(std::mem::size_of::<PxSoftBody>(), 24);
        assert_eq!(std::mem::size_of::<PxExtendedVec3>(), 24);
        assert_eq!(std::mem::size_of::<PxObstacle>(), 56);
        assert_eq!(std::mem::size_of::<PxBoxObstacle>(), 72);
        assert_eq!(std::mem::size_of::<PxCapsuleObstacle>(), 64);
        assert_eq!(std::mem::size_of::<PxControllerState>(), 48);
        assert_eq!(std::mem::size_of::<PxControllerStats>(), 8);
        assert_eq!(std::mem::size_of::<PxControllerHit>(), 64);
        assert_eq!(std::mem::size_of::<PxControllerShapeHit>(), 88);
        assert_eq!(std::mem::size_of::<PxControllersHit>(), 72);
        assert_eq!(std::mem::size_of::<PxControllerObstacleHit>(), 72);
        assert_eq!(std::mem::size_of::<PxControllerFilters>(), 32);
        assert_eq!(std::mem::size_of::<PxControllerDesc>(), 136);
        assert_eq!(std::mem::size_of::<PxBoxControllerDesc>(), 144);
        assert_eq!(std::mem::size_of::<PxCapsuleControllerDesc>(), 144);
        assert_eq!(std::mem::size_of::<PxDim3>(), 12);
        assert_eq!(std::mem::size_of::<PxSDFDesc>(), 160);
        assert_eq!(std::mem::size_of::<PxConvexMeshDesc>(), 88);
        assert_eq!(std::mem::size_of::<PxTriangleMeshDesc>(), 80);
        assert_eq!(std::mem::size_of::<PxTetrahedronMeshDesc>(), 72);
        assert_eq!(std::mem::size_of::<PxSoftBodySimulationDataDesc>(), 24);
        assert_eq!(std::mem::size_of::<PxBVH33MidphaseDesc>(), 8);
        assert_eq!(std::mem::size_of::<PxBVH34MidphaseDesc>(), 12);
        assert_eq!(std::mem::size_of::<PxMidphaseDesc>(), 16);
        assert_eq!(std::mem::size_of::<PxBVHDesc>(), 40);
        assert_eq!(std::mem::size_of::<PxCookingParams>(), 56);
        assert_eq!(std::mem::size_of::<PxJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxSpring>(), 8);
        assert_eq!(std::mem::size_of::<PxDistanceJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxJacobianRow>(), 48);
        assert_eq!(std::mem::size_of::<PxContactJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxFixedJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxJointLimitParameters>(), 20);
        assert_eq!(std::mem::size_of::<PxJointLinearLimit>(), 24);
        assert_eq!(std::mem::size_of::<PxJointLinearLimitPair>(), 28);
        assert_eq!(std::mem::size_of::<PxJointAngularLimitPair>(), 28);
        assert_eq!(std::mem::size_of::<PxJointLimitCone>(), 28);
        assert_eq!(std::mem::size_of::<PxJointLimitPyramid>(), 36);
        assert_eq!(std::mem::size_of::<PxPrismaticJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxRevoluteJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxSphericalJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxD6JointDrive>(), 16);
        assert_eq!(std::mem::size_of::<PxD6Joint>(), 24);
        assert_eq!(std::mem::size_of::<PxGearJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxRackAndPinionJoint>(), 24);
        assert_eq!(std::mem::size_of::<PxGroupsMask>(), 8);
        assert_eq!(std::mem::size_of::<PxRigidActorExt>(), 1);
        assert_eq!(std::mem::size_of::<PxMassProperties>(), 52);
        assert_eq!(std::mem::size_of::<PxRigidBodyExt>(), 1);
        assert_eq!(std::mem::size_of::<PxShapeExt>(), 1);
        assert_eq!(std::mem::size_of::<PxMeshOverlapUtil>(), 1040);
        assert_eq!(std::mem::size_of::<PxSerialization>(), 1);
        assert_eq!(std::mem::size_of::<PxStringTableExt>(), 1);
        assert_eq!(std::mem::size_of::<PxBroadPhaseExt>(), 1);
        assert_eq!(std::mem::size_of::<PxSceneQueryExt>(), 1);
        assert_eq!(std::mem::size_of::<PxBatchQueryStatus>(), 1);
        assert_eq!(std::mem::size_of::<PxSamplingExt>(), 1);
        assert_eq!(std::mem::size_of::<PxPoissonSampler>(), 8);
        assert_eq!(std::mem::size_of::<PxTriangleMeshPoissonSampler>(), 8);
        assert_eq!(std::mem::size_of::<PxTetrahedronMeshExt>(), 1);
        assert_eq!(std::mem::size_of::<PxRepXObject>(), 24);
        assert_eq!(std::mem::size_of::<PxRepXInstantiationArgs>(), 24);
        assert_eq!(std::mem::size_of::<PxVehicleContext>(), 52);
        assert_eq!(std::mem::size_of::<PxVehicleChassisData>(), 32);
        assert_eq!(std::mem::size_of::<PxVehicleEngineData>(), 112);
        assert_eq!(std::mem::size_of::<PxVehicleGearsData>(), 144);
        assert_eq!(std::mem::size_of::<PxVehicleAutoBoxData>(), 256);
        assert_eq!(std::mem::size_of::<PxVehicleDifferential4WData>(), 32);
        assert_eq!(std::mem::size_of::<PxVehicleDifferentialNWData>(), 16);
        assert_eq!(std::mem::size_of::<PxVehicleAckermannGeometryData>(), 16);
        assert_eq!(std::mem::size_of::<PxVehicleClutchData>(), 16);
        assert_eq!(std::mem::size_of::<PxVehicleTireLoadFilterData>(), 32);
        assert_eq!(std::mem::size_of::<PxVehicleWheelData>(), 48);
        assert_eq!(std::mem::size_of::<PxVehicleSuspensionData>(), 48);
        assert_eq!(std::mem::size_of::<PxVehicleAntiRollBarData>(), 16);
        assert_eq!(std::mem::size_of::<PxVehicleTireData>(), 64);
        assert_eq!(std::mem::size_of::<PxVehicleWheelsSimData>(), 96);
        assert_eq!(std::mem::size_of::<PxVehicleWheelsDynData>(), 48);
        assert_eq!(std::mem::size_of::<PxVehicleWheels>(), 192);
        assert_eq!(std::mem::size_of::<PxVehicleDriveSimData>(), 528);
        assert_eq!(std::mem::size_of::<PxVehicleDriveDynData>(), 96);
        assert_eq!(std::mem::size_of::<PxVehicleDrive>(), 288);
        assert_eq!(std::mem::size_of::<PxVehicleDriveSimData4W>(), 576);
        assert_eq!(std::mem::size_of::<PxVehicleDrive4W>(), 864);
        assert_eq!(std::mem::size_of::<PxVehicleDriveTank>(), 832);
        assert_eq!(std::mem::size_of::<PxVehicleDrivableSurfaceType>(), 4);
        assert_eq!(std::mem::size_of::<PxVehicleDrivableSurfaceToTireFrictionPairs>(), 48);
        assert_eq!(std::mem::size_of::<PxWheelQueryResult>(), 160);
        assert_eq!(std::mem::size_of::<PxVehicleWheelQueryResult>(), 16);
        assert_eq!(std::mem::size_of::<PxVehicleWheelConcurrentUpdateData>(), 64);
        assert_eq!(std::mem::size_of::<PxVehicleConcurrentUpdateData>(), 40);
        assert_eq!(std::mem::size_of::<PxVehicleDriveSimDataNW>(), 544);
        assert_eq!(std::mem::size_of::<PxVehicleDriveNW>(), 832);
        assert_eq!(std::mem::size_of::<PxVehicleSteerFilter>(), 8);
        assert_eq!(std::mem::size_of::<PxVehicleKeySmoothingData>(), 128);
        assert_eq!(std::mem::size_of::<PxVehiclePadSmoothingData>(), 128);
        assert_eq!(std::mem::size_of::<PxVehicleDriveTankRawInputData>(), 32);
        assert_eq!(std::mem::size_of::<PxVehicleCopyDynamicsMap>(), 40);
        assert_eq!(std::mem::size_of::<PxVehicleGraphDesc>(), 32);
        assert_eq!(std::mem::size_of::<PxVehicleGraphChannelDesc>(), 48);
        assert_eq!(std::mem::size_of::<PxVehicleGraph>(), 15840);
        assert_eq!(std::mem::size_of::<PxVehicleTelemetryData>(), 48);
        assert_eq!(std::mem::size_of::<PxVehicleNoDrive>(), 224);
    }
}

