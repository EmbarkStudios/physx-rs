---
source: physx-sys/pxbind/tests/methods.rs
expression: mo.rust
---
extern "C" {
    /// Decrements the reference count of a shape and releases it if the new reference count is zero.
    ///
    /// Note that in releases prior to PhysX 3.3 this method did not have reference counting semantics and was used to destroy a shape
    /// created with PxActor::createShape(). In PhysX 3.3 and above, this usage is deprecated, instead, use PxRigidActor::detachShape() to detach
    /// a shape from an actor. If the shape to be detached was created with PxActor::createShape(), the actor holds the only counted reference,
    /// and so when the shape is detached it will also be destroyed.
    pub fn PxShape_release_mut(self_: *mut physx_PxShape_Pod);

    /// Adjust the geometry of the shape.
    ///
    /// The type of the passed in geometry must match the geometry type of the shape.
    ///
    /// It is not allowed to change the geometry type of a shape.
    ///
    /// This function does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.
    pub fn PxShape_setGeometry_mut(self_: *mut physx_PxShape_Pod, geometry: *const physx_PxGeometry_Pod);

    /// Retrieve a reference to the shape's geometry.
    ///
    /// The returned reference has the same lifetime as the PxShape it comes from.
    ///
    /// Reference to internal PxGeometry object.
    pub fn PxShape_getGeometry(self_: *const physx_PxShape_Pod) -> *const physx_PxGeometry_Pod;

    /// Get the geometry type of the shape.
    ///
    /// Type of shape geometry.
    pub fn PxShape_getGeometryType(self_: *const physx_PxShape_Pod) -> PxGeometryType;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getBoxGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxBoxGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getSphereGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxSphereGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getCapsuleGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxCapsuleGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getPlaneGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxPlaneGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getConvexMeshGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxConvexMeshGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getTriangleMeshGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxTriangleMeshGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getTetrahedronMeshGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxTetrahedronMeshGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getParticleSystemGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxParticleSystemGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getHeightFieldGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxHeightFieldGeometry_Pod) -> bool;

    /// Fetch the geometry of the shape.
    ///
    /// If the type of geometry to extract does not match the geometry type of the shape
    /// then the method will return false and the passed in geometry descriptor is not modified.
    ///
    /// True on success else false
    pub fn PxShape_getCustomGeometry(self_: *const physx_PxShape_Pod, geometry: *mut physx_PxCustomGeometry_Pod) -> bool;

    /// Retrieves the actor which this shape is associated with.
    ///
    /// The actor this shape is associated with, if it is an exclusive shape, else NULL
    pub fn PxShape_getActor(self_: *const physx_PxShape_Pod) -> *mut physx_PxRigidActor_Pod;

    /// Sets the pose of the shape in actor space, i.e. relative to the actors to which they are attached.
    ///
    /// This transformation is identity by default.
    ///
    /// The local pose is an attribute of the shape, and so will apply to all actors to which the shape is attached.
    ///
    /// Sleeping:
    /// Does
    /// NOT
    /// wake the associated actor up automatically.
    ///
    /// Note:
    /// Does not automatically update the inertia properties of the owning actor (if applicable); use the
    /// PhysX extensions method [`PxRigidBodyExt::updateMassAndInertia`]() to do this.
    ///
    /// Default:
    /// the identity transform
    pub fn PxShape_setLocalPose_mut(self_: *mut physx_PxShape_Pod, pose: *const physx_PxTransform_Pod);

    /// Retrieves the pose of the shape in actor space, i.e. relative to the actor they are owned by.
    ///
    /// This transformation is identity by default.
    ///
    /// Pose of shape relative to the actor's frame.
    pub fn PxShape_getLocalPose(self_: *const physx_PxShape_Pod) -> physx_PxTransform_Pod;

    /// Sets the user definable collision filter data.
    ///
    /// Sleeping:
    /// Does wake up the actor if the filter data change causes a formerly suppressed
    /// collision pair to be enabled.
    ///
    /// Default:
    /// (0,0,0,0)
    pub fn PxShape_setSimulationFilterData_mut(self_: *mut physx_PxShape_Pod, data: *const physx_PxFilterData_Pod);

    /// Retrieves the shape's collision filter data.
    pub fn PxShape_getSimulationFilterData(self_: *const physx_PxShape_Pod) -> physx_PxFilterData_Pod;

    /// Sets the user definable query filter data.
    ///
    /// Default:
    /// (0,0,0,0)
    pub fn PxShape_setQueryFilterData_mut(self_: *mut physx_PxShape_Pod, data: *const physx_PxFilterData_Pod);

    /// Retrieves the shape's Query filter data.
    pub fn PxShape_getQueryFilterData(self_: *const physx_PxShape_Pod) -> physx_PxFilterData_Pod;

    /// Assigns material(s) to the shape. Will remove existing materials from the shape.
    ///
    /// Sleeping:
    /// Does
    /// NOT
    /// wake the associated actor up automatically.
    pub fn PxShape_setMaterials_mut(self_: *mut physx_PxShape_Pod, materials: *const *mut physx_PxMaterial_Pod, materialCount: u16);

    /// Assigns FEM soft body material(s) to the shape. Will remove existing materials from the shape.
    ///
    /// Sleeping:
    /// Does
    /// NOT
    /// wake the associated actor up automatically.
    pub fn PxShape_setSoftBodyMaterials_mut(self_: *mut physx_PxShape_Pod, materials: *const *mut physx_PxFEMSoftBodyMaterial_Pod, materialCount: u16);

    /// Assigns FEM cloth material(s) to the shape. Will remove existing materials from the shape.
    ///
    /// Feature under development, only for internal usage.
    ///
    /// Sleeping:
    /// Does
    /// NOT
    /// wake the associated actor up automatically.
    pub fn PxShape_setClothMaterials_mut(self_: *mut physx_PxShape_Pod, materials: *const *mut physx_PxFEMClothMaterial_Pod, materialCount: u16);

    /// Returns the number of materials assigned to the shape.
    ///
    /// You can use [`getMaterials`]() to retrieve the material pointers.
    ///
    /// Number of materials associated with this shape.
    pub fn PxShape_getNbMaterials(self_: *const physx_PxShape_Pod) -> u16;

    /// Retrieve all the material pointers associated with the shape.
    ///
    /// You can retrieve the number of material pointers by calling [`getNbMaterials`]()
    ///
    /// Note: The returned data may contain invalid pointers if you release materials using [`PxMaterial::release`]().
    ///
    /// Number of material pointers written to the buffer.
    pub fn PxShape_getMaterials(self_: *const physx_PxShape_Pod, userBuffer: *mut *mut physx_PxMaterial_Pod, bufferSize: u32, startIndex: u32) -> u32;

    /// Retrieve all the FEM soft body material pointers associated with the shape.
    ///
    /// You can retrieve the number of material pointers by calling [`getNbMaterials`]()
    ///
    /// Note: The returned data may contain invalid pointers if you release materials using [`PxMaterial::release`]().
    ///
    /// Number of material pointers written to the buffer.
    pub fn PxShape_getSoftBodyMaterials(self_: *const physx_PxShape_Pod, userBuffer: *mut *mut physx_PxFEMSoftBodyMaterial_Pod, bufferSize: u32, startIndex: u32) -> u32;

    /// Retrieve all the FEM cloth material pointers associated with the shape.
    ///
    /// Feature under development, only for internal usage.
    ///
    /// You can retrieve the number of material pointers by calling [`getNbMaterials`]()
    ///
    /// Note: The returned data may contain invalid pointers if you release materials using [`PxMaterial::release`]().
    ///
    /// Number of material pointers written to the buffer.
    pub fn PxShape_getClothMaterials(self_: *const physx_PxShape_Pod, userBuffer: *mut *mut physx_PxFEMClothMaterial_Pod, bufferSize: u32, startIndex: u32) -> u32;

    /// Retrieve material from given triangle index.
    ///
    /// The input index is the internal triangle index as used inside the SDK. This is the index
    /// returned to users by various SDK functions such as raycasts.
    ///
    /// This function is only useful for triangle meshes or heightfields, which have per-triangle
    /// materials. For other shapes or SDF triangle meshes, the function returns the single material
    /// associated with the	shape, regardless of the index.
    ///
    /// Material from input triangle
    ///
    /// If faceIndex value of 0xFFFFffff is passed as an input for mesh and heightfield shapes, this function will issue a warning and return NULL.
    ///
    /// Scene queries set the value of PxQueryHit::faceIndex to 0xFFFFffff whenever it is undefined or does not apply.
    pub fn PxShape_getMaterialFromInternalFaceIndex(self_: *const physx_PxShape_Pod, faceIndex: u32) -> *mut physx_PxBaseMaterial_Pod;

    /// Sets the contact offset.
    ///
    /// Shapes whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive and
    /// greater than the rest offset. Having a contactOffset greater than than the restOffset allows the collision detection system to
    /// predictively enforce the contact constraint even when the objects are slightly separated. This prevents jitter that would occur
    /// if the constraint were enforced only when shapes were within the rest distance.
    ///
    /// Default:
    /// 0.02f * PxTolerancesScale::length
    ///
    /// Sleeping:
    /// Does
    /// NOT
    /// wake the associated actor up automatically.
    pub fn PxShape_setContactOffset_mut(self_: *mut physx_PxShape_Pod, contactOffset: f32);

    /// Retrieves the contact offset.
    ///
    /// The contact offset of the shape.
    pub fn PxShape_getContactOffset(self_: *const physx_PxShape_Pod) -> f32;

    /// Sets the rest offset.
    ///
    /// Two shapes will come to rest at a distance equal to the sum of their restOffset values. If the restOffset is 0, they should converge to touching
    /// exactly.  Having a restOffset greater than zero is useful to have objects slide smoothly, so that they do not get hung up on irregularities of
    /// each others' surfaces.
    ///
    /// Default:
    /// 0.0f
    ///
    /// Sleeping:
    /// Does
    /// NOT
    /// wake the associated actor up automatically.
    pub fn PxShape_setRestOffset_mut(self_: *mut physx_PxShape_Pod, restOffset: f32);

    /// Retrieves the rest offset.
    ///
    /// The rest offset of the shape.
    pub fn PxShape_getRestOffset(self_: *const physx_PxShape_Pod) -> f32;

    /// Sets the density used to interact with fluids.
    ///
    /// To be physically accurate, the density of a rigid body should be computed as its mass divided by its volume. To
    /// simplify tuning the interaction of fluid and rigid bodies, the density for fluid can differ from the real density. This
    /// allows to create floating bodies, even if they are supposed to sink with their mass and volume.
    ///
    /// Default:
    /// 800.0f
    pub fn PxShape_setDensityForFluid_mut(self_: *mut physx_PxShape_Pod, densityForFluid: f32);

    /// Retrieves the density used to interact with fluids.
    ///
    /// The density of the body when interacting with fluid.
    pub fn PxShape_getDensityForFluid(self_: *const physx_PxShape_Pod) -> f32;

    /// Sets torsional patch radius.
    ///
    /// This defines the radius of the contact patch used to apply torsional friction. If the radius is 0, no torsional friction
    /// will be applied. If the radius is > 0, some torsional friction will be applied. This is proportional to the penetration depth
    /// so, if the shapes are separated or penetration is zero, no torsional friction will be applied. It is used to approximate
    /// rotational friction introduced by the compression of contacting surfaces.
    ///
    /// Default:
    /// 0.0
    pub fn PxShape_setTorsionalPatchRadius_mut(self_: *mut physx_PxShape_Pod, radius: f32);

    /// Gets torsional patch radius.
    ///
    /// This defines the radius of the contact patch used to apply torsional friction. If the radius is 0, no torsional friction
    /// will be applied. If the radius is > 0, some torsional friction will be applied. This is proportional to the penetration depth
    /// so, if the shapes are separated or penetration is zero, no torsional friction will be applied. It is used to approximate
    /// rotational friction introduced by the compression of contacting surfaces.
    ///
    /// The torsional patch radius of the shape.
    pub fn PxShape_getTorsionalPatchRadius(self_: *const physx_PxShape_Pod) -> f32;

    /// Sets minimum torsional patch radius.
    ///
    /// This defines the minimum radius of the contact patch used to apply torsional friction. If the radius is 0, the amount of torsional friction
    /// that will be applied will be entirely dependent on the value of torsionalPatchRadius.
    ///
    /// If the radius is > 0, some torsional friction will be applied regardless of the value of torsionalPatchRadius or the amount of penetration.
    ///
    /// Default:
    /// 0.0
    pub fn PxShape_setMinTorsionalPatchRadius_mut(self_: *mut physx_PxShape_Pod, radius: f32);

    /// Gets minimum torsional patch radius.
    ///
    /// This defines the minimum radius of the contact patch used to apply torsional friction. If the radius is 0, the amount of torsional friction
    /// that will be applied will be entirely dependent on the value of torsionalPatchRadius.
    ///
    /// If the radius is > 0, some torsional friction will be applied regardless of the value of torsionalPatchRadius or the amount of penetration.
    ///
    /// The minimum torsional patch radius of the shape.
    pub fn PxShape_getMinTorsionalPatchRadius(self_: *const physx_PxShape_Pod) -> f32;

    /// Sets shape flags
    ///
    /// Sleeping:
    /// Does
    /// NOT
    /// wake the associated actor up automatically.
    ///
    /// Default:
    /// PxShapeFlag::eVISUALIZATION | PxShapeFlag::eSIMULATION_SHAPE | PxShapeFlag::eSCENE_QUERY_SHAPE
    pub fn PxShape_setFlag_mut(self_: *mut physx_PxShape_Pod, flag: PxShapeFlag, value: bool);

    /// Sets shape flags
    pub fn PxShape_setFlags_mut(self_: *mut physx_PxShape_Pod, inFlags: PxShapeFlags);

    /// Retrieves shape flags.
    ///
    /// The values of the shape flags.
    pub fn PxShape_getFlags(self_: *const physx_PxShape_Pod) -> PxShapeFlags;

    /// Returns true if the shape is exclusive to an actor.
    pub fn PxShape_isExclusive(self_: *const physx_PxShape_Pod) -> bool;

    /// Sets a name string for the object that can be retrieved with [`getName`]().
    ///
    /// This is for debugging and is not used by the SDK.
    /// The string is not copied by the SDK, only the pointer is stored.
    ///
    /// Default:
    /// NULL
    pub fn PxShape_setName_mut(self_: *mut physx_PxShape_Pod, name: *const std::ffi::c_char);

    /// retrieves the name string set with setName().
    ///
    /// The name associated with the shape.
    pub fn PxShape_getName(self_: *const physx_PxShape_Pod) -> *const std::ffi::c_char;

    pub fn PxShape_getConcreteTypeName(self_: *const physx_PxShape_Pod) -> *const std::ffi::c_char;

}

