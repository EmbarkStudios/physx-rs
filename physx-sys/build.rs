//use cmake::Config;
use std::{
    env,
    path::{Path, PathBuf},
};

macro_rules! component {
    ($name:ident) => {
        fn $name(ctx: &mut Context) {
            let sources = include!(concat!("sources/", stringify!($name)));
            ctx.add_component(stringify!($name), &sources);
        }
    };
}

component! {common}
component! {fastxml}
component! {lowlevelaabb}
component! {lowleveldynamics}
component! {pvd}
component! {task}

// The foundation component is really the only one that references platform
// specific compilands, so just calculate them here
fn foundation(ctx: &mut Context) {
    let sources = include!("sources/foundation");
    ctx.add_component("foundation", &sources);

    let target_family = env::var("CARGO_CFG_TARGET_FAMILY").expect("TARGET_FAMILY not specified");
    let sources = match target_family.as_str() {
        "unix" => &include!("sources/foundation_unix"),
        "windows" => &include!("sources/foundation_windows"),
        other => panic!("unknown TARGET_FAMILY '{}'", other),
    };

    ctx.add_sources(&format!("source/foundation/src/{}", target_family), sources);
}

fn lowlevel(ctx: &mut Context) {
    // API
    ctx.builder
        .file(ctx.root.join("source/lowlevel/api/src/px_globals.cpp"));

    // pipeline
    {
        let sources = include!("sources/lowlevel_pipeline");
        ctx.add_sources("source/lowlevel/common/src/pipeline", &sources);
    }

    // software, otherwise known as non-gpu
    {
        let sources = include!("sources/lowlevel_software");
        ctx.add_sources("source/lowlevel/software/src", &sources);
    }

    ctx.add_includes(
        "source/lowlevel",
        &[
            "api/include",
            "common/include/collision",
            "common/include/pipeline",
            "common/include/utils",
            "software/include",
        ],
    );
}

fn vehicle(ctx: &mut Context) {
    let sources = include!("sources/vehicle");
    ctx.add_component("physxvehicle", &sources);

    let sources = include!("sources/vehicle_metadata");
    ctx.add_sources("source/physxvehicle/src/physxmetadata/src", &sources);

    ctx.add_includes("source/physxvehicle/src/physxmetadata", &["include"]);
}

fn extensions(ctx: &mut Context) {
    let sources = include!("sources/extensions");
    ctx.add_component("physxextensions", &sources);

    // metadata
    ctx.add_sources(
        "source/physxmetadata/extensions/src",
        &["PxExtensionAutoGeneratedMetaDataObjects"],
    );

    // xml
    let sources = include!("sources/extensions_xml");
    ctx.add_sources("source/physxextensions/src/serialization/Xml", &sources);

    ctx.add_includes("source/physxmetadata/extensions", &["include"]);
    ctx.add_includes("source/physxextensions/src/serialization", &["File"]);
}

component! {physxcharacterkinematic}

fn geomutils(ctx: &mut Context) {
    // root
    let sources = include!("sources/geomutils");
    ctx.add_sources("source/geomutils/src", &sources);
    ctx.add_includes("source/geomutils", &["include"]);

    // ccd
    let sources = include!("sources/geomutils_ccd");
    ctx.add_sources("source/geomutils/src/ccd", &sources);

    // common
    let sources = include!("sources/geomutils_common");
    ctx.add_sources("source/geomutils/src/common", &sources);

    // contact
    let sources = include!("sources/geomutils_contact");
    ctx.add_sources("source/geomutils/src/contact", &sources);

    // convex
    let sources = include!("sources/geomutils_convex");
    ctx.add_sources("source/geomutils/src/convex", &sources);

    // distance
    let sources = include!("sources/geomutils_distance");
    ctx.add_sources("source/geomutils/src/distance", &sources);

    // gjk
    let sources = include!("sources/geomutils_gjk");
    ctx.add_sources("source/geomutils/src/gjk", &sources);

    // hf
    let sources = include!("sources/geomutils_hf");
    ctx.add_sources("source/geomutils/src/hf", &sources);

    // intersection
    let sources = include!("sources/geomutils_intersection");
    ctx.add_sources("source/geomutils/src/intersection", &sources);

    // mesh
    let sources = include!("sources/geomutils_mesh");
    ctx.add_sources("source/geomutils/src/mesh", &sources);

    // pcm
    let sources = include!("sources/geomutils_pcm");
    ctx.add_sources("source/geomutils/src/pcm", &sources);

    // sweep
    let sources = include!("sources/geomutils_sweep");
    ctx.add_sources("source/geomutils/src/sweep", &sources);
}

fn cooking(ctx: &mut Context) {
    // root
    let sources = include!("sources/cooking");
    ctx.add_sources("source/physxcooking/src", &sources);
    ctx.add_includes("source/include", &["cooking"]);

    // mesh
    let sources = include!("sources/cooking_mesh");
    ctx.add_sources("source/physxcooking/src/mesh", &sources);

    // convex
    let sources = include!("sources/cooking_convex");
    ctx.add_sources("source/physxcooking/src/convex", &sources);

    // physx gates various cooking functionality with this define
    ctx.builder.define("PX_COOKING", None);
}

fn physx(ctx: &mut Context) {
    // metadata
    {
        let sources = ["PxAutoGeneratedMetaDataObjects", "PxMetaDataObjects"];
        ctx.add_sources("source/physxmetadata/core/src", &sources);
        ctx.add_includes("source", &["physxmetadata/core/include"]);
    }

    // immediate mode
    ctx.builder.file(
        ctx.root
            .join("source/immediatemode/src/NpImmediateMode.cpp"),
    );

    // buffering
    let sources = include!("sources/buffering");
    ctx.add_sources("source/physx/src/buffering", &sources);

    // there's always a "core"
    let sources = include!("sources/core");
    ctx.add_sources("source/physx/src", &sources);
}

component! {scenequery}
component! {simulationcontroller}

struct Environment {
    host: String,
    emit_debug_info: bool,
    target_os: String,
    target_arch: String,
    target_env: Option<String>,
    mode: String,
    target_compiler: Option<String>,
    target_linker: Option<String>,
}

fn add_common(ctx: &mut Context) {
    let shared_root = ctx.root.parent().unwrap().join("pxshared");

    let builder = &mut ctx.builder;
    let ccenv = &ctx.env;
    let root = &ctx.root;
    builder.cpp(true);

    // These includes are used by pretty much everything so just add them first
    ctx.includes.push(shared_root.join("include"));
    ctx.includes.extend(
        [
            "include",
            "source/foundation/include",
            "source/common/src",
            "source/filebuf/include", // only used by pvd
        ]
        .iter()
        .map(|inc| root.join(inc)),
    );

    // If we're targetting msvc, just silence all the annoying warnings
    if ccenv.target_env.as_ref().map(|s| s.as_str()) == Some("msvc") {
        builder
            .define("_CRT_SECURE_NO_WARNINGS", None)
            .define("_WINSOCK_DEPRECATED_NO_WARNINGS", None)
            .define("_ITERATOR_DEBUG_LEVEL", "0");
    }

    // Always build as a static library
    builder.define("PX_PHYSX_STATIC_LIB", None);
    // Always disable GPU features, at least for now
    builder.define("DISABLE_CUDA_PHYSX", None);

    if ccenv.emit_debug_info {
        builder
            .define("_DEBUG", "1")
            .define("PX_DEBUG", None)
            .define("PX_CHECKED", None);
    } else {
        builder.define("NDEBUG", "1");
    }

    // physx has 4 modes, but we only have 2, so just condition the visual
    // debugger on the cargo feature instead
    builder.define(
        "PX_SUPPORT_PVD",
        if env::var("CARGO_CFG_FEATURE_VISUAL_DEBUGGER").ok().is_some() {
            "1"
        } else {
            "0"
        },
    );

    // If we're on linux, we already require clang++ for structgen, for reasons,
    // so just force clang++ for the normal compile as well...except in the case
    // where a user has expliclity set CXX
    if ccenv.host.contains("-linux-") && ccenv.target_compiler.is_none() {
        builder.compiler("clang++");
    }

    let flags = if builder.get_compiler().is_like_clang() {
        vec![
            "-ferror-limit=0",
            "-Wall",
            "-Wextra",
            "-Werror",
            "-Wstrict-aliasing=2",
            "-Weverything",
            "-Wno-documentation-deprecated-sync",
            "-Wno-documentation-unknown-command",
            "-Wno-gnu-anonymous-struct",
            "-Wno-undef",
            "-Wno-unused-function",
            "-Wno-nested-anon-types",
            "-Wno-float-equal",
            "-Wno-padded",
            "-Wno-weak-vtables",
            "-Wno-cast-align",
            "-Wno-conversion",
            "-Wno-missing-noreturn",
            "-Wno-missing-variable-declarations",
            "-Wno-shift-sign-overflow",
            "-Wno-covered-switch-default",
            "-Wno-exit-time-destructors",
            "-Wno-global-constructors",
            "-Wno-missing-prototypes",
            "-Wno-unreachable-code",
            "-Wno-unused-macros",
            "-Wno-unused-member-function",
            "-Wno-used-but-marked-unused",
            "-Wno-weak-template-vtables",
            "-Wno-deprecated",
            "-Wno-non-virtual-dtor",
            "-Wno-invalid-noreturn",
            "-Wno-return-type-c-linkage",
            "-Wno-reserved-id-macro",
            "-Wno-c++98-compat-pedantic",
            "-Wno-unused-local-typedef",
            "-Wno-old-style-cast",
            "-Wno-newline-eof",
            "-Wno-unused-private-field",
            "-Wno-format-nonliteral",
            "-Wno-implicit-fallthrough",
            "-Wno-undefined-reinterpret-cast",
            "-Wno-disabled-macro-expansion",
            "-Wno-zero-as-null-pointer-constant",
            "-Wno-shadow",
            "-Wno-unknown-warning-option",
            "-Wno-atomic-implicit-seq-cst",
            "-Wno-extra-semi-stmt",
        ]
    } else {
        vec![]
    };

    for flag in flags {
        builder.flag(flag);
    }

    // cc sets PIC by default for most targets, but if we're compiling with
    // clang for windows, we need to unset it, as clang (at least as of 9)
    // doesn't support it
    if builder.get_compiler().is_like_clang() && ccenv.target_os == "windows" {
        builder.pic(false);
    }
}

struct Context {
    root: PathBuf,
    builder: cc::Build,
    env: Environment,
    includes: Vec<PathBuf>,
}

impl Context {
    fn add_includes(&mut self, rel_root: &str, includes: &[&str]) -> &mut Self {
        let root = self.root.join(rel_root);
        self.includes
            .extend(includes.iter().map(|inc| root.join(inc)));

        self
    }

    fn add_sources(&mut self, rel_root: &str, files: &[&str]) -> &mut Self {
        let root = self.root.join(rel_root);
        self.builder.files(files.iter().map(|src| {
            let mut p = root.join(src);
            p.set_extension("cpp");
            p
        }));

        // Always add the src directory as an include as well
        self.includes.push(root);

        self
    }

    fn add_component(&mut self, name: &str, sources: &[&str]) -> &mut Self {
        let src_dir = format!("source/{}/src", name);
        self.add_sources(&src_dir, sources);

        let mut comproot = self.root.join("source");
        comproot.push(name);
        self.includes.push(comproot.join("include"));

        self
    }
}

// In cross compilation scenarios, we _might_ need to build physx twice, once
// to get the actual libs that will be used on the target, and once for the
// host so that we can run the structgen process
fn compile_physx(target_env: Environment) {
    let root = env::current_dir().unwrap().join("PhysX/physx");
    let shared_root = root.parent().unwrap().join("pxshared");

    let ccenv = target_env;

    let mut ctx = Context {
        builder: cc::Build::new(),
        root,
        env: ccenv,
        includes: Vec::with_capacity(1000),
    };

    add_common(&mut ctx);

    // Add the sources and includes for each major physx component
    fastxml(&mut ctx);
    task(&mut ctx);
    foundation(&mut ctx);
    lowlevel(&mut ctx);
    lowlevelaabb(&mut ctx);
    lowleveldynamics(&mut ctx);
    vehicle(&mut ctx);
    extensions(&mut ctx);
    physxcharacterkinematic(&mut ctx);
    common(&mut ctx);
    geomutils(&mut ctx);
    cooking(&mut ctx);
    pvd(&mut ctx);
    physx(&mut ctx);
    scenequery(&mut ctx);
    simulationcontroller(&mut ctx);

    ctx.includes.push(ctx.root.join("source/pvd/include"));

    // Strip out duplicate include paths, C++ already has it hard enough as it is
    ctx.includes.sort();
    ctx.includes.dedup();

    for dir in ctx.includes {
        ctx.builder.include(dir);
    }

    ctx.builder.compile("physx");
}

fn main() {
    let physx_root_dir = env::current_dir().unwrap().join("PhysX/physx");
    let physx_parent_dir = physx_root_dir.parent().unwrap();

    // Use the optimization level to determine the build profile to pass, we
    // don't use cfg!(debug_assertions) here because I'm not sure what happens
    // with that when build dependencies are configured to be debug and the
    // actual target is meant to be release, so this seems safer
    let build_mode = match env::var("OPT_LEVEL")
        .ok()
        .and_then(|s| s.parse::<i32>().ok())
        .unwrap_or(1)
    {
        0 => "debug",
        _ => "profile",
    };

    let host = env::var("HOST").expect("HOST not specified");

    {
        let target_os = env::var("CARGO_CFG_TARGET_OS").expect("TARGET_OS not specified");
        let target_compiler = env::var("CXX").ok();
        let target_linker = env::var("RUSTC_LINKER").ok();
        let target_os = env::var("CARGO_CFG_TARGET_OS").expect("target os not specified");
        let target_arch =
            env::var("CARGO_CFG_TARGET_ARCH").expect("target architecture not specified");
        let output_dir = env::var("OUT_DIR").expect("output directory not specified");
        let target_env = env::var("CARGO_CFG_TARGET_ENV").ok();

        let target_out = compile_physx(Environment {
            emit_debug_info: env::var("DEBUG")
                .ok()
                .and_then(|s| s.parse::<bool>().ok())
                .unwrap_or(false),
            target_arch,
            target_os,
            target_env,
            target_compiler,
            target_linker,
            mode: build_mode.to_owned(),
            host: host.clone(),
        });
    }

    let mut cc_builder = cc::Build::new();
    let physx_cc = cc_builder
        .cpp(true)
        .opt_level(3)
        .debug(false)
        .use_plt(false)
        .warnings(false)
        .extra_warnings(false)
        .define("NDEBUG", None)
        .define("PX_PHYSX_STATIC_LIB", None)
        .include("PhysX/physx/include")
        .include("PhysX/pxshared/include")
        .include("PhysX/physx/source/foundation/include");

    if env::var("CXX").is_err() && host.contains("-linux-") {
        physx_cc.compiler("clang++");
    }

    physx_cc.flag(if physx_cc.get_compiler().is_like_msvc() {
        "/std:c++14"
    } else {
        "-std=c++14"
    });

    use std::ffi::OsString;
    let output_dir_path =
        PathBuf::from(env::var("OUT_DIR").expect("output directory not specified"));

    let include_path = if env::var("CARGO_FEATURE_STRUCTGEN").is_ok() {
        let mut structgen_path = output_dir_path.join("structgen");

        let structgen_compiler = physx_cc.get_compiler();
        let mut cmd = structgen_compiler.to_command();
        if structgen_compiler.is_like_msvc() {
            let mut s = OsString::from("/Fe");
            s.push(&structgen_path);
            cmd.arg(s);

            let mut s = OsString::from("/Fo");
            s.push(&structgen_path);
            s.push(".obj");
            cmd.arg(s);
        } else {
            cmd.arg("-o").arg(&structgen_path);
        }

        cmd.arg("src/structgen/structgen.cpp");
        cmd.status().expect("c++ compiler failed to execute");

        // The above status check has been shown to fail, ie, the compiler
        // fails to output a binary, but reports success anyway
        if host.contains("-windows-") {
            structgen_path.set_extension("exe");
        }

        std::fs::metadata(&structgen_path)
            .expect("failed to compile structgen even though compiler reported no failures");

        let mut structgen = std::process::Command::new(&structgen_path);
        structgen.current_dir(&output_dir_path);
        structgen.status().expect("structgen failed to execute");

        output_dir_path
    } else {
        let target = env::var("TARGET").expect("TARGET not specified");
        let mut include = PathBuf::from("src/generated");

        match target.as_str() {
            "x86_64-apple-darwin" | "x86_64-pc-windows-msvc" => {
                include.push(target);
            }
            nix if nix.starts_with("x86_64-unknown-linux") => {
                include.push("x86_64-unknown-linux");
            }
            _ => panic!("unknown TARGET triple '{}'", target),
        }

        include
    };

    physx_cc
        .include(include_path)
        .file("src/physx.cpp")
        .compile("physx_api");

    println!("cargo:rerun-if-changed=src/structgen/structgen.cpp");
    println!("cargo:rerun-if-changed=src/structgen/structgen.hpp");
    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=src/physx_generated.hpp");
    println!("cargo:rerun-if-changed=src/physx_generated.rs");
    println!("cargo:rerun-if-changed=src/physx.cpp");

    // TODO: use the cloned git revision number instead
    println!("cargo:rerun-if-changed=PhysX/physx/include/PxPhysicsVersion.h");

    // Remove PxConfig.h since we're only allowed to modify OUT_DIR.
    //let _ = std::fs::remove_file(physx_root_dir.join("include/PxConfig.h"));
}
